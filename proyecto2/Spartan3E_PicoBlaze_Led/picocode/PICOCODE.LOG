KCPSM3 Assembler log file for program 'picocode.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
16Oct2015-11:01:49

 Addr Code

 000                                 ; *
 000                                 ; * picocode.psm -  LED Control
 000                                 ; *
 000                                 ; *      ___       _         _   _       _ ___ _ _ ___
 000                                 ; * | __._ _ _| |_ ___ _| |_| |___ _| | . | \ |_ _|
 000                                 ; * | _>| ' ' | . / ._/ . / . / ._/ . |   |   || |
 000                                 ; * |___|_|_|_|___\___\___\___\___\___|_|_|_\_||_|
 000                                 ; *
 000                                 ; *
 000                                 ; *  Created on : 20/07/2015
 000                                 ; *      Author : Ernesto Andres Rincon Cruz
 000                                 ; *      Web  : www.embeddedant.org
 000                                 ; *    Device : XC3S700AN - 4FGG484
 000                                 ; *    Board  : Spartan-3AN Starter Kit.
 000                                 ; *
 000                                 ; *  Based on Ken Chapman code v1.00 - 4th January 2006
 000                                 ; *      Revision History:
 000                                 ; *   Rev 1.0.0 - (ErnestoARC) First release 16/08/2015.
 000                                 ; *
 000                                 ;//////////////////////////////////////////////////////////////////////////////////
 000                                 ; Use CONSTANT declarations to define output port addresses
 000                                 CONSTANT PORT_A, 00              ;
 000                                 ;;============================================================================
 000                                 ;;
 000                                 ;;============================================================================
 000                                 ADDRESS 000                      ; Programs always start at reset vector 0
 000  3C000                          DISABLE INTERRUPT                ; If using interrupts, be sure to enable the INTERRUPT input
 001                                 ;;============================================================================
 001                                 ;;
 001                                 ;;============================================================================
 001  00F3F                          LOAD sF, 3F
 002  34003                          JUMP __sdcc_program_startup[003]
 003                                 ;--------------------------------------------------------
 003                                 ; Home
 003                                 ;--------------------------------------------------------
 003         __sdcc_program_startup: 
 003  30005                          CALL _main[005]
 004                                 ; return from main will lock up
 004                    __sdcc_loop: 
 004  34004                          JUMP __sdcc_loop[004]
 005                                 ;--------------------------------------------------------
 005                                 ; code
 005                                 ;--------------------------------------------------------
 005                                 ; programa.c:20: void main()
 005                          _main: 
 005                                 ; programa.c:22: char cont_sato = 20;
 005  00014                          LOAD s0, 14
 006                                 ; programa.c:24: char cont_led = 100;
 006  00164                          LOAD s1, 64
 007                                 ; programa.c:25: led_on();
 007  2F0F0                          STORE s0, (sF)
 008  1CF01                          SUB sF, 01
 009  2F1F0                          STORE s1, (sF)
 00A  1CF01                          SUB sF, 01
 00B  3004D                          CALL _led_on[04D]
 00C  18F01                          ADD sF, 01
 00D  071F0                          FETCH s1, (sF)
 00E  18F01                          ADD sF, 01
 00F  070F0                          FETCH s0, (sF)
 010                                 ; programa.c:26: while(1)
 010                        _L00111: 
 010                                 ; programa.c:28: if (cont_sato == 0)
 010  14000                          COMPARE s0, 00
 011  35013                          JUMP Z, _LC00135[013]
 012  3401E                          JUMP _L00102[01E]
 013                       _LC00135: 
 013                                 ; programa.c:30: cont_sato = 20;
 013  00014                          LOAD s0, 14
 014                                 ; programa.c:31: saltar();
 014  2F0F0                          STORE s0, (sF)
 015  1CF01                          SUB sF, 01
 016  2F1F0                          STORE s1, (sF)
 017  1CF01                          SUB sF, 01
 018  30047                          CALL _saltar[047]
 019  18F01                          ADD sF, 01
 01A  071F0                          FETCH s1, (sF)
 01B  18F01                          ADD sF, 01
 01C  070F0                          FETCH s0, (sF)
 01D  3401F                          JUMP _L00103[01F]
 01E                        _L00102: 
 01E                                 ; programa.c:34: cont_sato --;
 01E  1C001                          SUB s0, 01
 01F                        _L00103: 
 01F                                 ; programa.c:36: if (cont_led == 50)
 01F  14132                          COMPARE s1, 32
 020  3542B                          JUMP NZ, _L00105[02B]
 021                                 ; programa.c:37: led_on();
 021  2F0F0                          STORE s0, (sF)
 022  1CF01                          SUB sF, 01
 023  2F1F0                          STORE s1, (sF)
 024  1CF01                          SUB sF, 01
 025  3004D                          CALL _led_on[04D]
 026  18F01                          ADD sF, 01
 027  071F0                          FETCH s1, (sF)
 028  18F01                          ADD sF, 01
 029  070F0                          FETCH s0, (sF)
 02A  3402C                          JUMP _L00106[02C]
 02B                        _L00105: 
 02B                                 ; programa.c:39: cont_led --;
 02B  1C101                          SUB s1, 01
 02C                        _L00106: 
 02C                                 ; programa.c:40: if (cont_led == 0)
 02C  14100                          COMPARE s1, 00
 02D  3502F                          JUMP Z, _LC00136[02F]
 02E  3403A                          JUMP _L00108[03A]
 02F                       _LC00136: 
 02F                                 ; programa.c:42: led_off();
 02F  2F0F0                          STORE s0, (sF)
 030  1CF01                          SUB sF, 01
 031  2F1F0                          STORE s1, (sF)
 032  1CF01                          SUB sF, 01
 033  30050                          CALL _led_off[050]
 034  18F01                          ADD sF, 01
 035  071F0                          FETCH s1, (sF)
 036  18F01                          ADD sF, 01
 037  070F0                          FETCH s0, (sF)
 038                                 ; programa.c:43: cont_led = 100;
 038  00164                          LOAD s1, 64
 039  3403B                          JUMP _L00109[03B]
 03A                        _L00108: 
 03A                                 ; programa.c:46: cont_led --;
 03A  1C101                          SUB s1, 01
 03B                        _L00109: 
 03B                                 ; programa.c:47: delay_ms(10);
 03B  2F0F0                          STORE s0, (sF)
 03C  1CF01                          SUB sF, 01
 03D  2F1F0                          STORE s1, (sF)
 03E  1CF01                          SUB sF, 01
 03F  00B0A                          LOAD sB, 0A
 040  00C00                          LOAD sC, 00
 041  3005B                          CALL _delay_ms[05B]
 042  18F01                          ADD sF, 01
 043  071F0                          FETCH s1, (sF)
 044  18F01                          ADD sF, 01
 045  070F0                          FETCH s0, (sF)
 046  34010                          JUMP _L00111[010]
 047                                 ; programa.c:51: void saltar()
 047                        _saltar: 
 047                                 ; programa.c:56: __endasm;
 047  0E702                          XOR s7, 02
 048  2C700                          OUTPUT s7, 00
 049                                 ; programa.c:57: delay();
 049  30053                          CALL _delay[053]
 04A                                 ; programa.c:61: __endasm;
 04A  0E702                          XOR s7, 02
 04B  2C700                          OUTPUT s7, 00
 04C  2A000                          RETURN
 04D                                 ; programa.c:64: void led_on()
 04D                        _led_on: 
 04D                                 ; programa.c:69: __endasm;
 04D  00701                          LOAD s7, 01
 04E  2C700                          OUTPUT s7, 00
 04F  2A000                          RETURN
 050                                 ; programa.c:72: void led_off()
 050                       _led_off: 
 050                                 ; programa.c:77: __endasm;
 050  00700                          LOAD s7, 00
 051  2C700                          OUTPUT s7, 00
 052  2A000                          RETURN
 053                                 ; programa.c:80: void delay()
 053                         _delay: 
 053                                 ; programa.c:94: __endasm;
 053                                 CONSTANT DELAY_LOOP2, 30         ; Loop delay
 053  00100                          LOAD s1, 00
 054                          _rpt2: 
 054  18101                          ADD s1, 01
 055  00000                          LOAD s0, 00
 056                          _rpt1: 
 056  18001                          ADD s0, 01
 057  35456                          JUMP NZ, _rpt1[056]
 058  14130                          COMPARE s1, DELAY_LOOP2[30]
 059  35454                          JUMP NZ, _rpt2[054]
 05A  2A000                          RETURN
 05B                                 ; programa.c:97: void delay_ms(int n)
 05B                      _delay_ms: 
 05B  010B0                          LOAD s0, sB
 05C  011C0                          LOAD s1, sC
 05D                                 ; programa.c:100: while(valor!=0)
 05D                        _L00127: 
 05D  01200                          LOAD s2, s0
 05E  0D210                          OR s2, s1
 05F  14200                          COMPARE s2, 00
 060  35462                          JUMP NZ, _LC00137[062]
 061  3406E                          JUMP _L00134[06E]
 062                       _LC00137: 
 062                                 ; programa.c:102: valor = valor - 1;
 062  1C001                          SUB s0, 01
 063  1E100                          SUBCY s1, 00
 064                                 ; programa.c:103: delay();
 064  2F0F0                          STORE s0, (sF)
 065  1CF01                          SUB sF, 01
 066  2F1F0                          STORE s1, (sF)
 067  1CF01                          SUB sF, 01
 068  30053                          CALL _delay[053]
 069  18F01                          ADD sF, 01
 06A  071F0                          FETCH s1, (sF)
 06B  18F01                          ADD sF, 01
 06C  070F0                          FETCH s0, (sF)
 06D  3405D                          JUMP _L00127[05D]
 06E                        _L00134: 
 06E  2A000                          RETURN
 06F                                 ;;============================================================================
 06F                                 ; Delay routine (~0.5s.)
 06F                                 ;;============================================================================
 06F                                 ; PicoBlaze requires 2 clocks per instruction
 06F                                 ; 2 + (4 + (4 + 4*256 + 4) * 256 + 4)*DELAY_LOOP + 2 =
 06F                                 ; 500ms = (4 + 264200*DELAY_LOOP )*(1/50MHz)
 06F                                 ; DELAY_LOOP = 0x5E
 06F                                 ; Use CONSTANT declarations to time delay refinition
 06F                                 CONSTANT DELAY_LOOP, 5E          ; Loop delay
 06F                          delay: 
 06F  00200                          LOAD s2, 00                      ; 2
 070  18201                    rpt3: ADD s2, 01                       ; 2---------------------------------------------|
 071                                 ;  ---------------------------------------------|
 071  00100                          LOAD s1, 00                      ; 2---------------------------------------------|
 072  18101                    rpt2: ADD s1, 01                       ; 2-------------------------------------|
 073                                 ;  -------------------------------------|
 073  00000                          LOAD s0, 00                      ; 2-------------------------------------|
 074  18001                    rpt1: ADD s0, 01                       ; 2 ---------------|
 075  35474                          JUMP NZ, rpt1[074]               ; 2 ----------4*256|
 076                                 ;  -------------------------------------|
 076  14100                          COMPARE s1, 00                   ; 2-------------------------------------|
 077  35472                          JUMP NZ, rpt2[072]               ; 2----------------(4 + 4*256 + 4) * DELAY_LOOP|
 078  1425E                          COMPARE s2, DELAY_LOOP[5E]       ; 2---------------------------------------------|
 079  35470                          JUMP NZ, rpt3[070]               ; 2---(4 + (4 + 4*256 + 4) * 256 + 4)*DELAY_LOOP|
 07A  2A000                          RETURN                           ; 2
 07B                                 ;;============================================================================
 07B                                 ;; An Interrupt Service Routine (ISR) is required if using interrupts
 07B                                 ;; Interrupts are automatically disabled when an interrupt is recognized
 07B                                 ;; Never re-enable interrupts during the ISR
 07B                                 ;; Use RETURNI DISABLE to leave interrupts disabled
 07B                                 ;;============================================================================
 07B                            ISR: 
 07B                                 ; <<< your interrupt code here >>>
 07B  38001                          RETURNI ENABLE                   ; Return from interrupt service routine
 07C                                 ;;============================================================================
 07C                                 ;; Interrupt service routine vector.
 07C                                 ;;============================================================================
 3FF                                 ADDRESS 3FF                      ; Interrupt vector is located at highest instruction address
 3FF  3407B                          JUMP ISR[07B]                    ; Jump to interrupt service routine, ISR
 3FF                                 ;;============================================================================
 3FF                                 ;;
 3FF                                 ;;============================================================================
