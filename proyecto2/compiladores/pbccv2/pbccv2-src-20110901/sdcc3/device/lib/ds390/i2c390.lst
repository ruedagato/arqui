                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 3.0.1 #6227 (Oct  2 2015) (Linux)
                              4 ; This file was generated Fri Oct  2 17:15:18 2015
                              5 ;--------------------------------------------------------
                              6 	.module i2c390
                              7 	.optsdcc -mds390 --model-flat24
                              8 	
                              9 ;--------------------------------------------------------
                             10 ; CPU specific extensions
                             11 ;--------------------------------------------------------
                             12 .flat24 on		; 24 bit flat addressing
                    0084     13 dpl1	=	0x84
                    0085     14 dph1	=	0x85
                    0086     15 dps	=	0x86
                    0093     16 dpx	=	0x93
                    0095     17 dpx1	=	0x95
                    009B     18 esp	=	0x9B
                    009C     19 ap	=	0x9C
                    009C     20 _ap	=	0x9C
                    00D1     21 mcnt0	=	0xD1
                    00D2     22 mcnt1	=	0xD2
                    00D3     23 ma	=	0xD3
                    00D4     24 mb	=	0xD4
                    00D5     25 mc	=	0xD5
                    00D1     26 F1	=	0xD1	; user flag
                             27 ;--------------------------------------------------------
                             28 ; Public variables in this module
                             29 ;--------------------------------------------------------
                             30 	.globl _i2c_recv
                             31 	.globl _I2CByteIn
                             32 	.globl _ByteOutI2C
                             33 	.globl _BitInI2C
                             34 	.globl _BitOutI2C
                             35 	.globl _I2CDelay
                             36 	.globl _I2CSendReceive_PARM_3
                             37 	.globl _I2CSendReceive_PARM_2
                             38 	.globl _i2c_recv_PARM_2
                             39 	.globl _I2CSendStop_PARM_3
                             40 	.globl _I2CSendStop_PARM_2
                             41 	.globl _i2cReceiveBuffer
                             42 	.globl _i2cTransmitBuffer
                             43 	.globl _I2CReset
                             44 	.globl _I2CStart
                             45 	.globl _I2CStop
                             46 	.globl _I2CSendStop
                             47 	.globl _I2CSendReceive
                             48 	.globl _I2CDumpError
                             49 ;--------------------------------------------------------
                             50 ; special function registers
                             51 ;--------------------------------------------------------
                    0080     52 _P4	=	0x0080
                    0081     53 _SP	=	0x0081
                    0082     54 _DPL	=	0x0082
                    0083     55 _DPH	=	0x0083
                    0084     56 _DPL1	=	0x0084
                    0085     57 _DPH1	=	0x0085
                    0086     58 _DPS	=	0x0086
                    0087     59 _PCON	=	0x0087
                    0088     60 _TCON	=	0x0088
                    0089     61 _TMOD	=	0x0089
                    008A     62 _TL0	=	0x008a
                    008B     63 _TL1	=	0x008b
                    008C     64 _TH0	=	0x008c
                    008D     65 _TH1	=	0x008d
                    008E     66 _CKCON	=	0x008e
                    0090     67 _P1	=	0x0090
                    0091     68 _EXIF	=	0x0091
                    0092     69 _P4CNT	=	0x0092
                    0093     70 _DPX	=	0x0093
                    0095     71 _DPX1	=	0x0095
                    0098     72 _SCON0	=	0x0098
                    0099     73 _SBUF0	=	0x0099
                    009B     74 _ESP	=	0x009b
                    009C     75 _AP	=	0x009c
                    009D     76 _ACON	=	0x009d
                    00A0     77 _P2	=	0x00a0
                    00A1     78 _P5	=	0x00a1
                    00A2     79 _P5CNT	=	0x00a2
                    00A8     80 _IE	=	0x00a8
                    00B0     81 _P3	=	0x00b0
                    00B8     82 _IP	=	0x00b8
                    00C0     83 _SCON1	=	0x00c0
                    00C1     84 _SBUF1	=	0x00c1
                    00C4     85 _PMR	=	0x00c4
                    00C6     86 _MCON	=	0x00c6
                    00C7     87 _TA	=	0x00c7
                    00C8     88 _T2CON	=	0x00c8
                    00C9     89 _T2MOD	=	0x00c9
                    00CA     90 _RCAP2L	=	0x00ca
                    00CA     91 _RTL2	=	0x00ca
                    00CB     92 _RCAP2H	=	0x00cb
                    00CB     93 _RTH2	=	0x00cb
                    00CC     94 _TL2	=	0x00cc
                    00CD     95 _TH2	=	0x00cd
                    00D0     96 _PSW	=	0x00d0
                    00D1     97 _MCNT0	=	0x00d1
                    00D2     98 _MCNT1	=	0x00d2
                    00D3     99 _MA	=	0x00d3
                    00D4    100 _MB	=	0x00d4
                    00D5    101 _MC	=	0x00d5
                    00D8    102 _WDCON	=	0x00d8
                    00E0    103 _ACC	=	0x00e0
                    00E8    104 _EIE	=	0x00e8
                    00EA    105 _MXAX	=	0x00ea
                    00F0    106 _B	=	0x00f0
                    00F8    107 _EIP	=	0x00f8
                    8C8A    108 _TMR0	=	0x8c8a
                    8D8B    109 _TMR1	=	0x8d8b
                    CDCC    110 _TMR2	=	0xcdcc
                    CBCA    111 _RCAP2	=	0xcbca
                            112 ;--------------------------------------------------------
                            113 ; special function bits
                            114 ;--------------------------------------------------------
                    0088    115 _IT0	=	0x0088
                    0089    116 _IE0	=	0x0089
                    008A    117 _IT1	=	0x008a
                    008B    118 _IE1	=	0x008b
                    008C    119 _TR0	=	0x008c
                    008D    120 _TF0	=	0x008d
                    008E    121 _TR1	=	0x008e
                    008F    122 _TF1	=	0x008f
                    0090    123 _T2	=	0x0090
                    0091    124 _T2EX	=	0x0091
                    0092    125 _RXD1	=	0x0092
                    0093    126 _TXD1	=	0x0093
                    0094    127 _INT2	=	0x0094
                    0095    128 _INT3	=	0x0095
                    0096    129 _INT4	=	0x0096
                    0097    130 _INT5	=	0x0097
                    0098    131 _RI_0	=	0x0098
                    0099    132 _TI_0	=	0x0099
                    009A    133 _RB8_0	=	0x009a
                    009B    134 _TB8_0	=	0x009b
                    009C    135 _REN_0	=	0x009c
                    009D    136 _SM2_0	=	0x009d
                    009E    137 _SM1_0	=	0x009e
                    009F    138 _SM0_0	=	0x009f
                    009F    139 _FE_0	=	0x009f
                    00A8    140 _EX0	=	0x00a8
                    00A9    141 _ET0	=	0x00a9
                    00AA    142 _EX1	=	0x00aa
                    00AB    143 _ET1	=	0x00ab
                    00AC    144 _ES0	=	0x00ac
                    00AD    145 _ET2	=	0x00ad
                    00AE    146 _ES1	=	0x00ae
                    00AF    147 _EA	=	0x00af
                    00B0    148 _RXD0	=	0x00b0
                    00B1    149 _TXD0	=	0x00b1
                    00B2    150 _INT0	=	0x00b2
                    00B3    151 _INT1	=	0x00b3
                    00B4    152 _T0	=	0x00b4
                    00B5    153 _T1	=	0x00b5
                    00B6    154 _WR	=	0x00b6
                    00B7    155 _RD	=	0x00b7
                    00B8    156 _PX0	=	0x00b8
                    00B9    157 _PT0	=	0x00b9
                    00BA    158 _PX1	=	0x00ba
                    00BB    159 _PT1	=	0x00bb
                    00BC    160 _PS0	=	0x00bc
                    00BD    161 _PT2	=	0x00bd
                    00BE    162 _PS1	=	0x00be
                    00C0    163 _RI_1	=	0x00c0
                    00C1    164 _TI_1	=	0x00c1
                    00C2    165 _RB8_1	=	0x00c2
                    00C3    166 _TB8_1	=	0x00c3
                    00C4    167 _REN_1	=	0x00c4
                    00C5    168 _SM2_1	=	0x00c5
                    00C6    169 _SM1_1	=	0x00c6
                    00C7    170 _SM0_1	=	0x00c7
                    00C7    171 _FE_1	=	0x00c7
                    00C8    172 _CP_RL	=	0x00c8
                    00C9    173 _C_T	=	0x00c9
                    00CA    174 _TR2	=	0x00ca
                    00CB    175 _EXEN2	=	0x00cb
                    00CC    176 _TCLK	=	0x00cc
                    00CD    177 _RCLK	=	0x00cd
                    00CE    178 _EXF2	=	0x00ce
                    00CF    179 _TF2	=	0x00cf
                    00D0    180 _P	=	0x00d0
                    00D1    181 _F1	=	0x00d1
                    00D2    182 _OV	=	0x00d2
                    00D3    183 _RS0	=	0x00d3
                    00D4    184 _RS1	=	0x00d4
                    00D5    185 _F0	=	0x00d5
                    00D6    186 _AC	=	0x00d6
                    00D7    187 _CY	=	0x00d7
                    00D8    188 _RWT	=	0x00d8
                    00D9    189 _EWT	=	0x00d9
                    00DA    190 _WDRF	=	0x00da
                    00DB    191 _WDIF	=	0x00db
                    00DC    192 _PFI	=	0x00dc
                    00DD    193 _EPFI	=	0x00dd
                    00DE    194 _POR	=	0x00de
                    00DF    195 _SMOD_1	=	0x00df
                    00E8    196 _EX2	=	0x00e8
                    00E9    197 _EX3	=	0x00e9
                    00EA    198 _EX4	=	0x00ea
                    00EB    199 _EX5	=	0x00eb
                    00EC    200 _EWDI	=	0x00ec
                    00ED    201 _C1IE	=	0x00ed
                    00EE    202 _C0IE	=	0x00ee
                    00EF    203 _CANBIE	=	0x00ef
                    00F8    204 _PX2	=	0x00f8
                    00F9    205 _PX3	=	0x00f9
                    00FA    206 _PX4	=	0x00fa
                    00FB    207 _PX5	=	0x00fb
                    00FC    208 _PWDI	=	0x00fc
                    00FD    209 _C1IP	=	0x00fd
                    00FE    210 _C0IP	=	0x00fe
                    00FF    211 _CANBIP	=	0x00ff
                            212 ;--------------------------------------------------------
                            213 ; overlayable register banks
                            214 ;--------------------------------------------------------
                            215 	.area REG_BANK_0	(REL,OVR,DATA)
   0000                     216 	.ds 8
                            217 ;--------------------------------------------------------
                            218 ; internal ram data
                            219 ;--------------------------------------------------------
                            220 	.area DSEG    (DATA)
                            221 ;--------------------------------------------------------
                            222 ; overlayable items in internal ram 
                            223 ;--------------------------------------------------------
                            224 	.area OSEG    (OVR,DATA)
                            225 ;--------------------------------------------------------
                            226 ; indirectly addressable internal ram data
                            227 ;--------------------------------------------------------
                            228 	.area ISEG    (DATA)
                            229 ;--------------------------------------------------------
                            230 ; absolute internal ram data
                            231 ;--------------------------------------------------------
                            232 	.area IABS    (ABS,DATA)
                            233 	.area IABS    (ABS,DATA)
                            234 ;--------------------------------------------------------
                            235 ; bit data
                            236 ;--------------------------------------------------------
                            237 	.area BSEG    (BIT)
                            238 ;--------------------------------------------------------
                            239 ; paged external ram data
                            240 ;--------------------------------------------------------
                            241 	.area PSEG    (PAG,XDATA)
                            242 ;--------------------------------------------------------
                            243 ; external ram data
                            244 ;--------------------------------------------------------
                            245 	.area XSEG    (XDATA)
   0000                     246 _i2cTransmitBuffer::
   0000                     247 	.ds 128
   0080                     248 _i2cReceiveBuffer::
   0080                     249 	.ds 128
   0100                     250 _I2CDelay_delay_1_1:
   0100                     251 	.ds 4
   0104                     252 _I2CSendStop_PARM_2:
   0104                     253 	.ds 1
   0105                     254 _I2CSendStop_PARM_3:
   0105                     255 	.ds 1
   0106                     256 _i2c_recv_PARM_2:
   0106                     257 	.ds 1
   0107                     258 _I2CSendReceive_PARM_2:
   0107                     259 	.ds 1
   0108                     260 _I2CSendReceive_PARM_3:
   0108                     261 	.ds 1
                            262 ;--------------------------------------------------------
                            263 ; absolute external ram data
                            264 ;--------------------------------------------------------
                            265 	.area XABS    (ABS,XDATA)
                            266 ;--------------------------------------------------------
                            267 ; external initialized ram data
                            268 ;--------------------------------------------------------
                            269 	.area XISEG   (XDATA)
   0000                     270 _i2cError:
   0000                     271 	.ds 1
                            272 ;--------------------------------------------------------
                            273 ; global & static initialisations
                            274 ;--------------------------------------------------------
                            275 	.area HOME    (CODE)
                            276 	.area GSINIT  (CODE)
                            277 	.area GSFINAL (CODE)
                            278 	.area GSINIT  (CODE)
                            279 ;--------------------------------------------------------
                            280 ; Home
                            281 ;--------------------------------------------------------
                            282 	.area HOME    (CODE)
                            283 	.area HOME    (CODE)
                            284 ;--------------------------------------------------------
                            285 ; code
                            286 ;--------------------------------------------------------
                            287 	.area CSEG    (CODE)
                            288 ;------------------------------------------------------------
                            289 ;Allocation info for local variables in function 'I2CDelay'
                            290 ;------------------------------------------------------------
                            291 ;delay                     Allocated with name '_I2CDelay_delay_1_1'
                            292 ;------------------------------------------------------------
                            293 ;	i2c390.c:69: void I2CDelay(volatile long delay) {
                            294 ;	-----------------------------------------
                            295 ;	 function I2CDelay
                            296 ;	-----------------------------------------
   0000                     297 _I2CDelay:
                    0002    298 	ar2 = 0x02
                    0003    299 	ar3 = 0x03
                    0004    300 	ar4 = 0x04
                    0005    301 	ar5 = 0x05
                    0006    302 	ar6 = 0x06
                    0007    303 	ar7 = 0x07
                    0000    304 	ar0 = 0x00
                    0001    305 	ar1 = 0x01
   0000 75 86 01            306 	mov     dps, #1
   0003 90s00r01r00         307 	mov     dptr, #_I2CDelay_delay_1_1
   0007 E5 82               308 	mov	a,dpl
   0009 F0                  309 	movx	@dptr,a
   000A A3                  310 	inc	dptr
   000B E5 83               311 	mov	a,dph
   000D F0                  312 	movx	@dptr,a
   000E A3                  313 	inc	dptr
   000F E5 93               314 	mov	a,dpx
   0011 F0                  315 	movx	@dptr,a
   0012 A3                  316 	inc	dptr
   0013 E5 F0               317 	mov	a,b
   0015 F0                  318 	movx	@dptr,a
   0016 75 86 00            319 	mov	dps,#0
                            320 ;	i2c390.c:70: while (delay--)
   0019                     321 00101$:
   0019 90s00r01r00         322 	mov	dptr,#_I2CDelay_delay_1_1
                            323 ;	genAssign: resultIsFar = FALSE
   001D E0                  324 	movx	a,@dptr
   001E FA                  325 	mov	r2,a
   001F A3                  326 	inc	dptr
   0020 E0                  327 	movx	a,@dptr
   0021 FB                  328 	mov	r3,a
   0022 A3                  329 	inc	dptr
   0023 E0                  330 	movx	a,@dptr
   0024 FC                  331 	mov	r4,a
   0025 A3                  332 	inc	dptr
   0026 E0                  333 	movx	a,@dptr
   0027 FD                  334 	mov	r5,a
   0028 90s00r01r00         335 	mov	dptr,#_I2CDelay_delay_1_1
   002C E0                  336 	movx	a,@dptr
   002D 24 FF               337 	add	a,#0xFF
   002F FE                  338 	mov	r6,a
   0030 A3                  339 	inc	dptr
   0031 E0                  340 	movx	a,@dptr
   0032 34 FF               341 	addc	a,#0xFF
   0034 FF                  342 	mov	r7,a
   0035 A3                  343 	inc	dptr
   0036 E0                  344 	movx	a,@dptr
   0037 34 FF               345 	addc	a,#0xFF
   0039 F8                  346 	mov	r0,a
   003A A3                  347 	inc	dptr
   003B E0                  348 	movx	a,@dptr
   003C 34 FF               349 	addc	a,#0xFF
   003E F9                  350 	mov	r1,a
                            351 ;	genAssign: resultIsFar = TRUE
   003F 90s00r01r00         352 	mov	dptr,#_I2CDelay_delay_1_1
   0043 EE                  353 	mov	a,r6
   0044 F0                  354 	movx	@dptr,a
   0045 A3                  355 	inc	dptr
   0046 EF                  356 	mov	a,r7
   0047 F0                  357 	movx	@dptr,a
   0048 A3                  358 	inc	dptr
   0049 E8                  359 	mov	a,r0
   004A F0                  360 	movx	@dptr,a
   004B A3                  361 	inc	dptr
   004C E9                  362 	mov	a,r1
   004D F0                  363 	movx	@dptr,a
   004E EA                  364 	mov	a,r2
   004F 4B                  365 	orl	a,r3
   0050 4C                  366 	orl	a,r4
   0051 4D                  367 	orl	a,r5
   0052 70 C5               368 	jnz  00101$
   0054                     369 00107$:
   0054                     370 00104$:
   0054 22                  371 	ret
                            372 ;------------------------------------------------------------
                            373 ;Allocation info for local variables in function 'I2CReset'
                            374 ;------------------------------------------------------------
                            375 ;------------------------------------------------------------
                            376 ;	i2c390.c:81: char I2CReset(void)
                            377 ;	-----------------------------------------
                            378 ;	 function I2CReset
                            379 ;	-----------------------------------------
   0055                     380 _I2CReset:
                            381 ;	i2c390.c:83: SDA_LOW;
                            382 ;	i2c390.c:84: SCL_LOW;
   0055 53 A1 FC            383 	anl  _P5,#(0xFD & 0xFE)
                            384 ;	i2c390.c:85: SCL_HIGH;
   0058 43 A1 01            385 	orl	_P5,#0x01
                            386 ;	i2c390.c:86: SDA_HIGH;
   005B 43 A1 02            387 	orl	_P5,#0x02
                            388 ;	i2c390.c:87: i2cError = 0;
                            389 ;	genAssign: resultIsFar = TRUE
   005E 90s00r00r00         390 	mov	dptr,#_i2cError
   0062 E4                  391 	clr  a
   0063 F0                  392 	movx	@dptr,a
                            393 ;	i2c390.c:88: return (SCL_IN && SDA_IN);
   0064 E5 A1               394 	mov	a,_P5
   0066 30 E0 08            395 	jnb  acc.0,00103$
   0069                     396 00107$:
   0069 E5 A1               397 	mov	a,_P5
   006B C3                  398 	clr	c
   006C 13                  399 	rrc	a
   006D FA                  400 	mov  r2,a
   006E 20 E0 04            401 	jb   acc.0,00104$
   0071                     402 00108$:
   0071                     403 00103$:
                            404 ;	genAssign: resultIsFar = FALSE
   0071 7A 00               405 	mov	r2,#0x00
   0073 80 02               406 	sjmp 00105$
   0075                     407 00104$:
                            408 ;	genAssign: resultIsFar = FALSE
   0075 7A 01               409 	mov	r2,#0x01
   0077                     410 00105$:
   0077 8A 82               411 	mov	dpl,r2
   0079                     412 00101$:
   0079 22                  413 	ret
                            414 ;------------------------------------------------------------
                            415 ;Allocation info for local variables in function 'I2CStart'
                            416 ;------------------------------------------------------------
                            417 ;------------------------------------------------------------
                            418 ;	i2c390.c:97: char I2CStart(void)
                            419 ;	-----------------------------------------
                            420 ;	 function I2CStart
                            421 ;	-----------------------------------------
   007A                     422 _I2CStart:
                            423 ;	i2c390.c:99: SDA_HIGH;
   007A 43 A1 02            424 	orl	_P5,#0x02
                            425 ;	i2c390.c:100: SCL_HIGH;
   007D 43 A1 01            426 	orl	_P5,#0x01
                            427 ;	i2c390.c:101: I2CDelay(I2CDELAY);
   0080 90 00 00 01         428 	mov	dptr,#0x000001
   0084 75 F0 00            429 	mov	b,#0x00
   0087 12s00r00r00         430 	lcall	_I2CDelay
                            431 ;	i2c390.c:102: SDA_LOW;        /* Pull SDA down... */
   008B 53 A1 FD            432 	anl	_P5,#0xFD
                            433 ;	i2c390.c:103: I2CDelay(I2CDELAY);
   008E 90 00 00 01         434 	mov	dptr,#0x000001
   0092 75 F0 00            435 	mov	b,#0x00
   0095 12s00r00r00         436 	lcall	_I2CDelay
                            437 ;	i2c390.c:104: SCL_LOW;        /* ...and then SCL -> start condition. */
   0099 53 A1 FE            438 	anl	_P5,#0xFE
                            439 ;	i2c390.c:105: I2CDelay(I2CDELAY);
   009C 90 00 00 01         440 	mov	dptr,#0x000001
   00A0 75 F0 00            441 	mov	b,#0x00
   00A3 12s00r00r00         442 	lcall	_I2CDelay
                            443 ;	i2c390.c:106: return 0;
   00A7 75 82 00            444 	mov	dpl,#0x00
   00AA                     445 00101$:
   00AA 22                  446 	ret
                            447 ;------------------------------------------------------------
                            448 ;Allocation info for local variables in function 'I2CStop'
                            449 ;------------------------------------------------------------
                            450 ;------------------------------------------------------------
                            451 ;	i2c390.c:115: char I2CStop(void)
                            452 ;	-----------------------------------------
                            453 ;	 function I2CStop
                            454 ;	-----------------------------------------
   00AB                     455 _I2CStop:
                            456 ;	i2c390.c:117: SDA_LOW;
   00AB 53 A1 FD            457 	anl	_P5,#0xFD
                            458 ;	i2c390.c:118: SCL_HIGH;        /* Let SCL go up */
   00AE 43 A1 01            459 	orl	_P5,#0x01
                            460 ;	i2c390.c:119: I2CDelay(I2CDELAY);
   00B1 90 00 00 01         461 	mov	dptr,#0x000001
   00B5 75 F0 00            462 	mov	b,#0x00
   00B8 12s00r00r00         463 	lcall	_I2CDelay
                            464 ;	i2c390.c:120: SDA_HIGH;        /* ...and then SDA up -> stop condition. */
   00BC 43 A1 02            465 	orl	_P5,#0x02
                            466 ;	i2c390.c:121: I2CDelay(I2CDELAY);
   00BF 90 00 00 01         467 	mov	dptr,#0x000001
   00C3 75 F0 00            468 	mov	b,#0x00
   00C6 12s00r00r00         469 	lcall	_I2CDelay
                            470 ;	i2c390.c:123: return (SCL_IN && SDA_IN);  /* Both will be up, if everything is fine */
   00CA E5 A1               471 	mov	a,_P5
   00CC 30 E0 08            472 	jnb  acc.0,00103$
   00CF                     473 00107$:
   00CF E5 A1               474 	mov	a,_P5
   00D1 C3                  475 	clr	c
   00D2 13                  476 	rrc	a
   00D3 FA                  477 	mov  r2,a
   00D4 20 E0 04            478 	jb   acc.0,00104$
   00D7                     479 00108$:
   00D7                     480 00103$:
                            481 ;	genAssign: resultIsFar = FALSE
   00D7 7A 00               482 	mov	r2,#0x00
   00D9 80 02               483 	sjmp 00105$
   00DB                     484 00104$:
                            485 ;	genAssign: resultIsFar = FALSE
   00DB 7A 01               486 	mov	r2,#0x01
   00DD                     487 00105$:
   00DD 8A 82               488 	mov	dpl,r2
   00DF                     489 00101$:
   00DF 22                  490 	ret
                            491 ;------------------------------------------------------------
                            492 ;Allocation info for local variables in function 'BitOutI2C'
                            493 ;------------------------------------------------------------
                            494 ;bout                      Allocated to registers r2 
                            495 ;------------------------------------------------------------
                            496 ;	i2c390.c:132: char BitOutI2C(unsigned char bout)
                            497 ;	-----------------------------------------
                            498 ;	 function BitOutI2C
                            499 ;	-----------------------------------------
   00E0                     500 _BitOutI2C:
   00E0 AA 82               501 	mov	r2,dpl
                            502 ;	i2c390.c:134: SDA_OUT(bout);              /* Put data out on SDA */
   00E2 EA                  503 	mov	a,r2
   00E3 60 05               504 	jz  00108$
   00E5                     505 00114$:
   00E5 43 A1 02            506 	orl	_P5,#0x02
   00E8 80 03               507 	sjmp 00109$
   00EA                     508 00108$:
   00EA 53 A1 FD            509 	anl	_P5,#0xFD
   00ED                     510 00109$:
                            511 ;	i2c390.c:135: I2CDelay(I2CDELAY);
   00ED C0 02               512 	push	ar2
   00EF 90 00 00 01         513 	mov	dptr,#0x000001
   00F3 75 F0 00            514 	mov	b,#0x00
   00F6 12s00r00r00         515 	lcall	_I2CDelay
   00FA D0 02               516 	pop	ar2
                            517 ;	i2c390.c:136: SCL_HIGH;                   /* Let SCL go up */
   00FC 43 A1 01            518 	orl	_P5,#0x01
                            519 ;	i2c390.c:137: while(!SCL_IN)              /* Wait until all other devices are ready */
   00FF                     520 00101$:
   00FF E5 A1               521 	mov	a,_P5
   0101 30 E0 FB            522 	jnb  acc.0,00101$
   0104                     523 00115$:
                            524 ;	i2c390.c:142: if (SDA_IN != bout)         /* Arbitration lost, release bus and return */
   0104 E5 A1               525 	mov	a,_P5
   0106 C3                  526 	clr	c
   0107 13                  527 	rrc	a
   0108 54 01               528 	anl  a,#0x01
   010A FB                  529 	mov  r3,a
   010B B5 02 02            530 	cjne	a,ar2,00116$
   010E 80 16               531 	sjmp 00105$
   0110                     532 00116$:
                            533 ;	i2c390.c:144: SDA_HIGH;               /* Should be up anyway, but make sure */
   0110 43 A1 02            534 	orl	_P5,#0x02
                            535 ;	i2c390.c:145: i2cError = I2CERR_LOST;
                            536 ;	genAssign: resultIsFar = TRUE
   0113 90s00r00r00         537 	mov	dptr,#_i2cError
   0117 74 02               538 	mov	a,#0x02
   0119 F0                  539 	movx	@dptr,a
                            540 ;	i2c390.c:146: I2CDumpError(i2cError);
   011A 75 82 02            541 	mov	dpl,#0x02
   011D 12s00r03rCA         542 	lcall	_I2CDumpError
                            543 ;	i2c390.c:147: return 1;
   0121 75 82 01            544 	mov	dpl,#0x01
   0124 80 1C               545 	sjmp 00106$
   0126                     546 00105$:
                            547 ;	i2c390.c:149: I2CDelay(I2CDELAY);
   0126 90 00 00 01         548 	mov	dptr,#0x000001
   012A 75 F0 00            549 	mov	b,#0x00
   012D 12s00r00r00         550 	lcall	_I2CDelay
                            551 ;	i2c390.c:150: SCL_LOW;                    /* Pull SCL back down */
   0131 53 A1 FE            552 	anl	_P5,#0xFE
                            553 ;	i2c390.c:151: I2CDelay(I2CDELAY);
   0134 90 00 00 01         554 	mov	dptr,#0x000001
   0138 75 F0 00            555 	mov	b,#0x00
   013B 12s00r00r00         556 	lcall	_I2CDelay
                            557 ;	i2c390.c:152: return 0;                   /* OK */
   013F 75 82 00            558 	mov	dpl,#0x00
   0142                     559 00106$:
   0142 22                  560 	ret
                            561 ;------------------------------------------------------------
                            562 ;Allocation info for local variables in function 'BitInI2C'
                            563 ;------------------------------------------------------------
                            564 ;bin                       Allocated to registers r2 
                            565 ;------------------------------------------------------------
                            566 ;	i2c390.c:160: char BitInI2C(void)
                            567 ;	-----------------------------------------
                            568 ;	 function BitInI2C
                            569 ;	-----------------------------------------
   0143                     570 _BitInI2C:
                            571 ;	i2c390.c:165: SDA_HIGH;
   0143 43 A1 02            572 	orl	_P5,#0x02
                            573 ;	i2c390.c:167: SCL_HIGH;                   /* Let SCL go up */
   0146 43 A1 01            574 	orl	_P5,#0x01
                            575 ;	i2c390.c:168: while(!SCL_IN)              /* Wait for other devices */
   0149                     576 00101$:
   0149 E5 A1               577 	mov	a,_P5
   014B 30 E0 FB            578 	jnb  acc.0,00101$
   014E                     579 00108$:
                            580 ;	i2c390.c:172: bin = SDA_IN;               /* Read in data */
   014E E5 A1               581 	mov	a,_P5
   0150 C3                  582 	clr	c
   0151 13                  583 	rrc	a
   0152 FA                  584 	mov	r2,a
   0153 53 02 01            585 	anl	ar2,#0x01
                            586 ;	i2c390.c:173: I2CDelay(I2CDELAY);
   0156 C0 02               587 	push	ar2
   0158 90 00 00 01         588 	mov	dptr,#0x000001
   015C 75 F0 00            589 	mov	b,#0x00
   015F 12s00r00r00         590 	lcall	_I2CDelay
   0163 D0 02               591 	pop	ar2
                            592 ;	i2c390.c:174: SCL_LOW;                    /* Pull SCL back up */
   0165 53 A1 FE            593 	anl	_P5,#0xFE
                            594 ;	i2c390.c:175: I2CDelay(I2CDELAY);
   0168 C0 02               595 	push	ar2
   016A 90 00 00 01         596 	mov	dptr,#0x000001
   016E 75 F0 00            597 	mov	b,#0x00
   0171 12s00r00r00         598 	lcall	_I2CDelay
   0175 D0 02               599 	pop	ar2
                            600 ;	i2c390.c:176: return bin;                 /* Return the sampled bit */
   0177 8A 82               601 	mov	dpl,r2
   0179                     602 00104$:
   0179 22                  603 	ret
                            604 ;------------------------------------------------------------
                            605 ;Allocation info for local variables in function 'ByteOutI2C'
                            606 ;------------------------------------------------------------
                            607 ;dat                       Allocated to registers r2 
                            608 ;bit_count                 Allocated to registers 
                            609 ;------------------------------------------------------------
                            610 ;	i2c390.c:187: char ByteOutI2C(char dat)
                            611 ;	-----------------------------------------
                            612 ;	 function ByteOutI2C
                            613 ;	-----------------------------------------
   017A                     614 _ByteOutI2C:
   017A AA 82               615 	mov	r2,dpl
                            616 ;	i2c390.c:192: while(bit_count) {
                            617 ;	genAssign: resultIsFar = FALSE
   017C 7B 08               618 	mov	r3,#0x08
   017E                     619 00108$:
   017E EB                  620 	mov	a,r3
   017F 60 53               621 	jz  00110$
   0181                     622 00121$:
                            623 ;	i2c390.c:193: if (dat & 0x80) {
   0181 EA                  624 	mov	a,r2
   0182 30 E7 23            625 	jnb  acc.7,00106$
   0185                     626 00122$:
                            627 ;	i2c390.c:194: if (BitOutI2C(1)) {
   0185 C0 02               628 	push	ar2
   0187 C0 03               629 	push	ar3
   0189 75 82 01            630 	mov	dpl,#0x01
   018C 12s00r00rE0         631 	lcall	_BitOutI2C
   0190 D0 03               632 	pop	ar3
   0192 D0 02               633 	pop	ar2
   0194 E5 82               634 	mov	a,dpl
   0196 60 33               635 	jz  00107$
   0198                     636 00123$:
                            637 ;	i2c390.c:195: I2CDumpError(i2cError);
   0198 90s00r00r00         638 	mov	dptr,#_i2cError
   019C E0                  639 	movx	a,@dptr
   019D F5 82               640 	mov	dpl,a
   019F 12s00r03rCA         641 	lcall	_I2CDumpError
                            642 ;	i2c390.c:196: return 1;
   01A3 75 82 01            643 	mov	dpl,#0x01
   01A6 80 49               644 	sjmp 00113$
   01A8                     645 00106$:
                            646 ;	i2c390.c:199: if (BitOutI2C(0)) {
   01A8 C0 02               647 	push	ar2
   01AA C0 03               648 	push	ar3
   01AC 75 82 00            649 	mov	dpl,#0x00
   01AF 12s00r00rE0         650 	lcall	_BitOutI2C
   01B3 D0 03               651 	pop	ar3
   01B5 D0 02               652 	pop	ar2
   01B7 E5 82               653 	mov	a,dpl
   01B9 60 10               654 	jz  00107$
   01BB                     655 00124$:
                            656 ;	i2c390.c:200: I2CDumpError(i2cError);
   01BB 90s00r00r00         657 	mov	dptr,#_i2cError
   01BF E0                  658 	movx	a,@dptr
   01C0 F5 82               659 	mov	dpl,a
   01C2 12s00r03rCA         660 	lcall	_I2CDumpError
                            661 ;	i2c390.c:201: return 1;
   01C6 75 82 01            662 	mov	dpl,#0x01
   01C9 80 26               663 	sjmp 00113$
   01CB                     664 00107$:
                            665 ;	i2c390.c:204: dat <<= 1;
   01CB EA                  666 	mov	a,r2
   01CC 25 E0               667 	add	a,acc
   01CE FC                  668 	mov	r4,a
                            669 ;	genAssign: resultIsFar = TRUE
   01CF 8C 02               670 	mov	ar2,r4
                            671 ;	i2c390.c:205: bit_count--;
   01D1 1B                  672 	dec	r3
   01D2 80 AA               673 	sjmp 00108$
   01D4                     674 00110$:
                            675 ;	i2c390.c:208: if (BitInI2C()) {
   01D4 12s00r01r43         676 	lcall	_BitInI2C
   01D8 E5 82               677 	mov	a,dpl
   01DA 60 12               678 	jz  00112$
   01DC                     679 00125$:
                            680 ;	i2c390.c:209: i2cError = I2CERR_NAK;
                            681 ;	genAssign: resultIsFar = TRUE
   01DC 90s00r00r00         682 	mov	dptr,#_i2cError
   01E0 74 01               683 	mov	a,#0x01
   01E2 F0                  684 	movx	@dptr,a
                            685 ;	i2c390.c:210: I2CDumpError(i2cError);
   01E3 75 82 01            686 	mov	dpl,#0x01
   01E6 12s00r03rCA         687 	lcall	_I2CDumpError
                            688 ;	i2c390.c:211: return 1;
   01EA 75 82 01            689 	mov	dpl,#0x01
                            690 ;	i2c390.c:213: return 0;
   01ED 22                  691 	ret
   01EE                     692 00112$:
   01EE 75 82 00            693 	mov     dpl,#0x00
   01F1                     694 00113$:
   01F1 22                  695 	ret
                            696 ;------------------------------------------------------------
                            697 ;Allocation info for local variables in function 'I2CByteIn'
                            698 ;------------------------------------------------------------
                            699 ;ack                       Allocated to registers r2 
                            700 ;bit_count                 Allocated to registers 
                            701 ;byte_in                   Allocated to registers r3 
                            702 ;------------------------------------------------------------
                            703 ;	i2c390.c:224: char I2CByteIn(char ack)
                            704 ;	-----------------------------------------
                            705 ;	 function I2CByteIn
                            706 ;	-----------------------------------------
   01F2                     707 _I2CByteIn:
   01F2 AA 82               708 	mov	r2,dpl
                            709 ;	i2c390.c:229: byte_in = 0;
                            710 ;	genAssign: resultIsFar = TRUE
   01F4 7B 00               711 	mov	r3,#0x00
                            712 ;	i2c390.c:231: while(bit_count)
                            713 ;	genAssign: resultIsFar = FALSE
   01F6 7C 08               714 	mov	r4,#0x08
   01F8                     715 00103$:
   01F8 EC                  716 	mov	a,r4
   01F9 60 20               717 	jz  00105$
   01FB                     718 00112$:
                            719 ;	i2c390.c:233: byte_in <<= 1;
   01FB EB                  720 	mov	a,r3
   01FC 25 E0               721 	add	a,acc
   01FE FD                  722 	mov	r5,a
                            723 ;	genAssign: resultIsFar = TRUE
   01FF 8D 03               724 	mov	ar3,r5
                            725 ;	i2c390.c:234: if (BitInI2C()) byte_in |= 0x01;
   0201 C0 02               726 	push	ar2
   0203 C0 03               727 	push	ar3
   0205 C0 04               728 	push	ar4
   0207 12s00r01r43         729 	lcall	_BitInI2C
   020B D0 04               730 	pop	ar4
   020D D0 03               731 	pop	ar3
   020F D0 02               732 	pop	ar2
   0211 E5 82               733 	mov	a,dpl
   0213 60 03               734 	jz  00102$
   0215                     735 00113$:
   0215 43 03 01            736 	orl	ar3,#0x01
   0218                     737 00102$:
                            738 ;	i2c390.c:235: bit_count--;
   0218 1C                  739 	dec	r4
   0219 80 DD               740 	sjmp 00103$
   021B                     741 00105$:
                            742 ;	i2c390.c:238: BitOutI2C(ack);
   021B C0 03               743 	push	ar3
   021D 8A 82               744 	mov	dpl,r2
   021F 12s00r00rE0         745 	lcall	_BitOutI2C
   0223 D0 03               746 	pop	ar3
                            747 ;	i2c390.c:239: SDA_HIGH;             /* Added 18-Jul-95 - thanks to Ray Bellis */
   0225 43 A1 02            748 	orl	_P5,#0x02
                            749 ;	i2c390.c:240: return byte_in;
   0228 8B 82               750 	mov	dpl,r3
   022A                     751 00106$:
   022A 22                  752 	ret
                            753 ;------------------------------------------------------------
                            754 ;Allocation info for local variables in function 'I2CSendStop'
                            755 ;------------------------------------------------------------
                            756 ;count                     Allocated with name '_I2CSendStop_PARM_2'
                            757 ;send_stop                 Allocated with name '_I2CSendStop_PARM_3'
                            758 ;addr                      Allocated to registers r2 
                            759 ;byteptr                   Allocated to registers 
                            760 ;byte_out                  Allocated to registers r2 
                            761 ;------------------------------------------------------------
                            762 ;	i2c390.c:249: char I2CSendStop(char addr, char count, char send_stop)
                            763 ;	-----------------------------------------
                            764 ;	 function I2CSendStop
                            765 ;	-----------------------------------------
   022B                     766 _I2CSendStop:
   022B AA 82               767 	mov	r2,dpl
                            768 ;	i2c390.c:253: if (I2CStart()) return 1;
   022D C0 02               769 	push	ar2
   022F 12s00r00r7A         770 	lcall	_I2CStart
   0233 D0 02               771 	pop	ar2
   0235 E5 82               772 	mov	a,dpl
   0237 60 05               773 	jz  00102$
   0239                     774 00122$:
   0239 75 82 01            775 	mov	dpl,#0x01
   023C 80 75               776 	sjmp 00113$
   023E                     777 00102$:
                            778 ;	i2c390.c:254: i2cError = 0;
                            779 ;	genAssign: resultIsFar = TRUE
   023E 90s00r00r00         780 	mov	dptr,#_i2cError
   0242 E4                  781 	clr  a
   0243 F0                  782 	movx	@dptr,a
                            783 ;	i2c390.c:256: byte_out = addr & 0xfe;     /* Ensure that it's a write address */
   0244 53 02 FE            784 	anl	ar2,#0xFE
                            785 ;	i2c390.c:257: count++;                    /* Include slave address to byte count */
   0247 90s00r01r04         786 	mov	dptr,#_I2CSendStop_PARM_2
   024B E0                  787 	movx	a,@dptr
   024C 24 01               788 	add	a,#0x01
   024E F0                  789 	movx	@dptr,a
                            790 ;	i2c390.c:259: while(count)
                            791 ;	genAssign: resultIsFar = FALSE
   024F 7B 00               792 	mov	r3,#0x00
   0251 90s00r01r04         793 	mov	dptr,#_I2CSendStop_PARM_2
                            794 ;	genAssign: resultIsFar = FALSE
   0255 E0                  795 	movx	a,@dptr
   0256 FC                  796 	mov	r4,a
   0257                     797 00108$:
   0257 EC                  798 	mov	a,r4
   0258 60 4B               799 	jz  00110$
   025A                     800 00123$:
                            801 ;	i2c390.c:261: if (ByteOutI2C(byte_out))
   025A C0 03               802 	push	ar3
   025C C0 04               803 	push	ar4
   025E 8A 82               804 	mov	dpl,r2
   0260 12s00r01r7A         805 	lcall	_ByteOutI2C
   0264 D0 04               806 	pop	ar4
   0266 D0 03               807 	pop	ar3
   0268 E5 82               808 	mov	a,dpl
   026A 60 22               809 	jz  00107$
   026C                     810 00124$:
                            811 ;	i2c390.c:263: if (i2cError == I2CERR_NAK && send_stop) I2CStop();
   026C 90s00r00r00         812 	mov	dptr,#_i2cError
   0270 E0                  813 	movx	a,@dptr
   0271 B4 01 0B            814 	cjne a,#0x01,00104$
   0274                     815 00126$:
   0274 90s00r01r05         816 	mov	dptr,#_I2CSendStop_PARM_3
   0278 E0                  817 	movx	a,@dptr
   0279 60 04               818 	jz  00104$
   027B                     819 00127$:
   027B 12s00r00rAB         820 	lcall	_I2CStop
   027F                     821 00104$:
                            822 ;	i2c390.c:264: return i2cError;
   027F 75 86 01            823 	mov     dps, #1
   0282 90s00r00r00         824 	mov     dptr, #_i2cError
   0286 E0                  825 	movx	a,@dptr
   0287 F5 82               826 	mov	dpl,a
   0289 75 86 00            827 	mov	dps,#0
   028C 80 25               828 	sjmp 00113$
   028E                     829 00107$:
                            830 ;	i2c390.c:266: byte_out = i2cTransmitBuffer[byteptr];
   028E EB                  831 	mov	a,r3
   028F 24r00               832 	add	a,#_i2cTransmitBuffer
   0291 F5 82               833 	mov	dpl,a
   0293 E4                  834 	clr	a
   0294 34s00               835 	addc	a,#(_i2cTransmitBuffer >> 8)
   0296 F5 83               836 	mov	dph,a
   0298 E4                  837 	clr	a
   0299 34s00               838 	addc	a,#(_i2cTransmitBuffer >> 16)
   029B F5 93               839 	mov	dpx,a
   029D E0                  840 	movx	a,@dptr
   029E FD                  841 	mov	r5,a
                            842 ;	genAssign: resultIsFar = TRUE
   029F 8D 02               843 	mov	ar2,r5
                            844 ;	i2c390.c:267: byteptr++;
   02A1 0B                  845 	inc	r3
                            846 ;	i2c390.c:268: count--;
   02A2 1C                  847 	dec	r4
   02A3 80 B2               848 	sjmp 00108$
   02A5                     849 00110$:
                            850 ;	i2c390.c:271: if (send_stop) I2CStop();
   02A5 90s00r01r05         851 	mov	dptr,#_I2CSendStop_PARM_3
   02A9 E0                  852 	movx	a,@dptr
   02AA 60 04               853 	jz  00112$
   02AC                     854 00128$:
   02AC 12s00r00rAB         855 	lcall	_I2CStop
   02B0                     856 00112$:
                            857 ;	i2c390.c:272: return 0;
   02B0 75 82 00            858 	mov	dpl,#0x00
   02B3                     859 00113$:
   02B3 22                  860 	ret
                            861 ;------------------------------------------------------------
                            862 ;Allocation info for local variables in function 'i2c_recv'
                            863 ;------------------------------------------------------------
                            864 ;count                     Allocated with name '_i2c_recv_PARM_2'
                            865 ;addr                      Allocated to registers r2 
                            866 ;byteptr                   Allocated to registers 
                            867 ;byte_in                   Allocated to registers r2 
                            868 ;------------------------------------------------------------
                            869 ;	i2c390.c:281: char i2c_recv(char addr, char count)
                            870 ;	-----------------------------------------
                            871 ;	 function i2c_recv
                            872 ;	-----------------------------------------
   02B4                     873 _i2c_recv:
   02B4 AA 82               874 	mov	r2,dpl
                            875 ;	i2c390.c:285: if (I2CStart()) return 1;
   02B6 C0 02               876 	push	ar2
   02B8 12s00r00r7A         877 	lcall	_I2CStart
   02BC D0 02               878 	pop	ar2
   02BE E5 82               879 	mov	a,dpl
   02C0 60 07               880 	jz  00102$
   02C2                     881 00125$:
   02C2 75 82 01            882 	mov	dpl,#0x01
   02C5 02s00r03r55         883 	ljmp	00113$
   02C9                     884 00102$:
                            885 ;	i2c390.c:286: i2cError = 0;
                            886 ;	genAssign: resultIsFar = TRUE
   02C9 90s00r00r00         887 	mov	dptr,#_i2cError
   02CD E4                  888 	clr  a
   02CE F0                  889 	movx	@dptr,a
                            890 ;	i2c390.c:289: byte_in = addr | 0x01;
   02CF 43 02 01            891 	orl	ar2,#0x01
                            892 ;	i2c390.c:291: if (ByteOutI2C(byte_in))
   02D2 8A 82               893 	mov	dpl,r2
   02D4 12s00r01r7A         894 	lcall	_ByteOutI2C
   02D8 E5 82               895 	mov	a,dpl
   02DA 60 1B               896 	jz  00122$
   02DC                     897 00126$:
                            898 ;	i2c390.c:293: if (i2cError == I2CERR_NAK) I2CStop();
   02DC 90s00r00r00         899 	mov	dptr,#_i2cError
   02E0 E0                  900 	movx	a,@dptr
   02E1 B4 01 04            901 	cjne a,#0x01,00104$
   02E4                     902 00128$:
   02E4 12s00r00rAB         903 	lcall	_I2CStop
   02E8                     904 00104$:
                            905 ;	i2c390.c:294: return i2cError;
   02E8 75 86 01            906 	mov     dps, #1
   02EB 90s00r00r00         907 	mov     dptr, #_i2cError
   02EF E0                  908 	movx	a,@dptr
   02F0 F5 82               909 	mov	dpl,a
   02F2 75 86 00            910 	mov	dps,#0
                            911 ;	i2c390.c:297: while(count)
   02F5 80 5E               912 	sjmp 00113$
   02F7                     913 00122$:
   02F7 90s00r01r06         914 	mov	dptr,#_i2c_recv_PARM_2
                            915 ;	genAssign: resultIsFar = FALSE
   02FB E0                  916 	movx	a,@dptr
   02FC FB                  917 	mov	r3,a
                            918 ;	genAssign: resultIsFar = FALSE
   02FD 7C 00               919 	mov	r4,#0x00
   02FF                     920 00110$:
   02FF EB                  921 	mov	a,r3
   0300 60 40               922 	jz  00112$
   0302                     923 00129$:
                            924 ;	i2c390.c:299: count-=1;
   0302 1B                  925 	dec	r3
                            926 ;	i2c390.c:300: if (count) {
   0303 EB                  927 	mov	a,r3
   0304 60 15               928 	jz  00108$
   0306                     929 00130$:
                            930 ;	i2c390.c:301: byte_in = I2CByteIn(0);
   0306 C0 03               931 	push	ar3
   0308 C0 04               932 	push	ar4
   030A 75 82 00            933 	mov	dpl,#0x00
   030D 12s00r01rF2         934 	lcall	_I2CByteIn
   0311 AD 82               935 	mov	r5,dpl
   0313 D0 04               936 	pop	ar4
   0315 D0 03               937 	pop	ar3
                            938 ;	genAssign: resultIsFar = TRUE
   0317 8D 02               939 	mov	ar2,r5
   0319 80 13               940 	sjmp 00109$
   031B                     941 00108$:
                            942 ;	i2c390.c:303: byte_in = I2CByteIn(1);   /* No ACK during last byte */
   031B C0 03               943 	push	ar3
   031D C0 04               944 	push	ar4
   031F 75 82 01            945 	mov	dpl,#0x01
   0322 12s00r01rF2         946 	lcall	_I2CByteIn
   0326 AD 82               947 	mov	r5,dpl
   0328 D0 04               948 	pop	ar4
   032A D0 03               949 	pop	ar3
                            950 ;	genAssign: resultIsFar = TRUE
   032C 8D 02               951 	mov	ar2,r5
   032E                     952 00109$:
                            953 ;	i2c390.c:305: i2cReceiveBuffer[byteptr] = byte_in;
   032E EC                  954 	mov	a,r4
   032F 24r80               955 	add	a,#_i2cReceiveBuffer
   0331 F5 82               956 	mov	dpl,a
   0333 E4                  957 	clr	a
   0334 34s00               958 	addc	a,#(_i2cReceiveBuffer >> 8)
   0336 F5 83               959 	mov	dph,a
   0338 E4                  960 	clr	a
   0339 34s00               961 	addc	a,#(_i2cReceiveBuffer >> 16)
   033B F5 93               962 	mov	dpx,a
   033D EA                  963 	mov	a,r2
   033E F0                  964 	movx	@dptr,a
                            965 ;	i2c390.c:306: byteptr++;
   033F 0C                  966 	inc	r4
   0340 80 BD               967 	sjmp 00110$
   0342                     968 00112$:
                            969 ;	i2c390.c:309: I2CStop();
   0342 12s00r00rAB         970 	lcall	_I2CStop
                            971 ;	i2c390.c:311: return (i2cError ? 1 : 0);
   0346 90s00r00r00         972 	mov	dptr,#_i2cError
   034A E0                  973 	movx	a,@dptr
   034B 60 04               974 	jz  00115$
   034D                     975 00131$:
                            976 ;	genAssign: resultIsFar = FALSE
   034D 7A 01               977 	mov	r2,#0x01
   034F 80 02               978 	sjmp 00116$
   0351                     979 00115$:
                            980 ;	genAssign: resultIsFar = FALSE
   0351 7A 00               981 	mov	r2,#0x00
   0353                     982 00116$:
   0353 8A 82               983 	mov	dpl,r2
   0355                     984 00113$:
   0355 22                  985 	ret
                            986 ;------------------------------------------------------------
                            987 ;Allocation info for local variables in function 'I2CSendReceive'
                            988 ;------------------------------------------------------------
                            989 ;tx_count                  Allocated with name '_I2CSendReceive_PARM_2'
                            990 ;rx_count                  Allocated with name '_I2CSendReceive_PARM_3'
                            991 ;addr                      Allocated to registers r2 
                            992 ;------------------------------------------------------------
                            993 ;	i2c390.c:322: char I2CSendReceive(char addr, char tx_count, char rx_count)
                            994 ;	-----------------------------------------
                            995 ;	 function I2CSendReceive
                            996 ;	-----------------------------------------
   0356                     997 _I2CSendReceive:
   0356 AA 82               998 	mov	r2,dpl
                            999 ;	i2c390.c:324: if (I2CSendStop(addr, tx_count, 0))
   0358 90s00r01r07        1000 	mov	dptr,#_I2CSendReceive_PARM_2
                           1001 ;	genAssign: resultIsFar = TRUE
   035C E0                 1002 	movx	a,@dptr
   035D 90s00r01r04        1003 	mov	dptr,#_I2CSendStop_PARM_2
   0361 F0                 1004 	movx	@dptr,a
                           1005 ;	genAssign: resultIsFar = TRUE
   0362 90s00r01r05        1006 	mov	dptr,#_I2CSendStop_PARM_3
   0366 E4                 1007 	clr  a
   0367 F0                 1008 	movx	@dptr,a
   0368 C0 02              1009 	push	ar2
   036A 8A 82              1010 	mov	dpl,r2
   036C 12s00r02r2B        1011 	lcall	_I2CSendStop
   0370 D0 02              1012 	pop	ar2
   0372 E5 82              1013 	mov	a,dpl
   0374 60 13              1014 	jz  00104$
   0376                    1015 00115$:
                           1016 ;	i2c390.c:329: if (i2cError != I2CERR_LOST) I2CStop();
   0376 90s00r00r00        1017 	mov	dptr,#_i2cError
   037A E0                 1018 	movx	a,@dptr
   037B B4 02 02           1019 	cjne	a,#0x02,00116$
   037E 80 04              1020 	sjmp 00102$
   0380                    1021 00116$:
   0380 12s00r00rAB        1022 	lcall	_I2CStop
   0384                    1023 00102$:
                           1024 ;	i2c390.c:330: return 1;
   0384 75 82 01           1025 	mov	dpl,#0x01
   0387 80 40              1026 	sjmp 00107$
   0389                    1027 00104$:
                           1028 ;	i2c390.c:333: SDA_HIGH; /* One of these may be low now, in which case the next */
   0389 43 A1 02           1029 	orl	_P5,#0x02
                           1030 ;	i2c390.c:334: SCL_HIGH; /* start condition wouldn't be detected so make */
   038C 43 A1 01           1031 	orl	_P5,#0x01
                           1032 ;	i2c390.c:335: I2CDelay(I2CDELAY); /*   sure that they're up and wait for one delay slot */
   038F C0 02              1033 	push	ar2
   0391 90 00 00 01        1034 	mov	dptr,#0x000001
   0395 75 F0 00           1035 	mov	b,#0x00
   0398 12s00r00r00        1036 	lcall	_I2CDelay
   039C D0 02              1037 	pop	ar2
                           1038 ;	i2c390.c:337: if (i2c_recv((char)(addr|0x01), rx_count)) return 1;
   039E 43 02 01           1039 	orl	ar2,#0x01
   03A1 90s00r01r08        1040 	mov	dptr,#_I2CSendReceive_PARM_3
                           1041 ;	genAssign: resultIsFar = TRUE
   03A5 E0                 1042 	movx	a,@dptr
   03A6 90s00r01r06        1043 	mov	dptr,#_i2c_recv_PARM_2
   03AA F0                 1044 	movx	@dptr,a
   03AB 8A 82              1045 	mov	dpl,r2
   03AD 12s00r02rB4        1046 	lcall	_i2c_recv
   03B1 E5 82              1047 	mov	a,dpl
   03B3 60 05              1048 	jz  00106$
   03B5                    1049 00117$:
   03B5 75 82 01           1050 	mov	dpl,#0x01
   03B8 80 0F              1051 	sjmp 00107$
   03BA                    1052 00106$:
                           1053 ;	i2c390.c:338: return (i2cError ? 1 : 0);
   03BA 90s00r00r00        1054 	mov	dptr,#_i2cError
   03BE E0                 1055 	movx	a,@dptr
   03BF 60 04              1056 	jz  00109$
   03C1                    1057 00118$:
                           1058 ;	genAssign: resultIsFar = FALSE
   03C1 7A 01              1059 	mov	r2,#0x01
   03C3 80 02              1060 	sjmp 00110$
   03C5                    1061 00109$:
                           1062 ;	genAssign: resultIsFar = FALSE
   03C5 7A 00              1063 	mov	r2,#0x00
   03C7                    1064 00110$:
   03C7 8A 82              1065 	mov	dpl,r2
   03C9                    1066 00107$:
   03C9 22                 1067 	ret
                           1068 ;------------------------------------------------------------
                           1069 ;Allocation info for local variables in function 'I2CDumpError'
                           1070 ;------------------------------------------------------------
                           1071 ;error                     Allocated to registers 
                           1072 ;------------------------------------------------------------
                           1073 ;	i2c390.c:345: void I2CDumpError(char error)
                           1074 ;	-----------------------------------------
                           1075 ;	 function I2CDumpError
                           1076 ;	-----------------------------------------
   03CA                    1077 _I2CDumpError:
                           1078 ;	i2c390.c:370: error; // hush the compiler
   03CA                    1079 00101$:
   03CA 22                 1080 	ret
                           1081 	.area CSEG    (CODE)
                           1082 	.area CONST   (CODE)
                           1083 	.area XINIT   (CODE)
   0000                    1084 __xinit__i2cError:
   0000 00                 1085 	.db #0x00	;  0
                           1086 	.area CABS    (ABS,CODE)
