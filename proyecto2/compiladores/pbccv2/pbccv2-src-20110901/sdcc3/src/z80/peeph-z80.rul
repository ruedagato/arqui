/* Generated file, DO NOT Edit!  */
/* To Make changes to rules edit */
/* <port>/peeph.def instead.     */
"\n"
"replace restart {\n"
"	ld	%1, %1\n"
"} by {\n"
"	; peephole -1 removed redundant load.\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1, %2\n"
"} by {\n"
"	; peephole 0a removed dead load from %2 into %1.\n"
"} if notVolatile(%1), notUsed(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1, %2 + %3\n"
"} by {\n"
"	; peephole 0a' removed dead load from %2 + %3 into %1.\n"
"} if notVolatile(%1), notUsed(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1, %2\n"
"	ld	%3, %1\n"
"} by {\n"
"	; peephole 0b loaded %3 from %2 directly instead of going through %1.\n"
"	ld	%3, %2\n"
"} if canAssign(%3 %2), notVolatile(%1), notUsed(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1, %2\n"
"	ld	%3, %4\n"
"	ld	%5, %1\n"
"} by {\n"
"	ld	%5, %2\n"
"	; peephole 0b'-v5 loaded %5 from %2 directly instead of going through %1.\n"
"	ld	%3, %4\n"
"} if canAssign(%5 %2), notVolatile(%1), operandsNotRelated(%1 %4), operandsNotRelated(%1 %3), operandsNotRelated(%4 %5), notUsed(%1), notSame(%3 %4 '(hl)' '(de)' '(bc)'), notVolatile(%5)\n"
"replace restart {\n"
"	ld	%1, %2\n"
"	ld	%3, %4\n"
"	ld	%5, %1\n"
"} by {\n"
"	ld	%5, %2\n"
"	; peephole 0b'-v4 loaded %5 from %2 directly instead of going through %1.\n"
"	ld	%3, %4\n"
"} if canAssign(%5 %2), notVolatile(%1), operandsNotRelated(%1 %4), operandsNotRelated(%1 %3), operandsNotRelated(%4 %5), notUsed(%1), notSame(%3 %4 '(hl)' '(de)' '(bc)'), notVolatile(%4), notSame(%1 '(hl)' '(de)' '(bc)'), notSame(%5 '(hl)' '(de)' '(bc)')\n"
"\n"
"replace restart {\n"
"	ld	%1, %2 (%3)\n"
"	ld	%4, %1\n"
"} by {\n"
"	; peephole 0c1 loaded %2 (%3) into %4 directly instead of going through %1.\n"
"	ld	%4, %2 (%3)\n"
"} if canAssign(%4 %2 %3), notVolatile(%1), notUsed(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1, %2\n"
"	ld	%3 (%4), %1\n"
"} by {\n"
"	; peephole 0c2 loaded %2 into %3 (%4) directly instead of going through %1.\n"
"	ld	%3 (%4), %2\n"
"} if canAssign(%3 %4 %2), notVolatile(%1), notUsed(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1, %2 (%3)\n"
"	ld	%4, %5 (%6)\n"
"	ld	%7, %1\n"
"} by {\n"
"	ld	%7, %2 (%3)\n"
"	; peephole 0c3 loaded %2 (%3) into %7 directly instead of going through %1.\n"
"	ld	%4, %5 (%6)\n"
"} if canAssign(%7 %2 %3), notVolatile(%1), notUsed(%1), notSame(%1 %4), notSame(%7 %4)\n"
"\n"
"replace restart {\n"
"	ld	%1, %7\n"
"	ld	%5 (%6), %4\n"
"	ld	%2 (%3), %1\n"
"} by {\n"
"	ld	%5 (%6), %4\n"
"	; peephole 0c4 loaded %7 into %2 (%3) directly instead of going through %1.\n"
"	ld	%2 (%3), %7\n"
"} if canAssign(%2 %3 %7), notVolatile(%1), notUsed(%1), notSame(%1 %4)\n"
"\n"
"replace restart {\n"
"	ld	%1, %2 (%3)\n"
"	ld	%4, %5\n"
"	ld	%7, %1\n"
"} by {\n"
"	ld	%7, %2 (%3)\n"
"	; peephole 0c5 loaded %2 (%3) into %7 directly instead of going through %1.\n"
"	ld	%4, %5\n"
"} if canAssign(%7 %2 %3), notVolatile(%1), notUsed(%1), notSame(%1 %5), notSame(%7 %4), notSame(%4 '(hl)' '(de)' '(bc)')\n"
"\n"
"replace restart {\n"
"	ld	%1,#%2\n"
"	ld	a,%3 (%1)\n"
"} by {\n"
"	; peephole 0d loaded %2 into a directly instead of going through %1.\n"
"	ld	a,(#%2 + %3)\n"
"} if notUsed(%1)\n"
"\n"
"replace restart {\n"
"	ld	hl,#%1\n"
"	ld	a,(hl)\n"
"} by {\n"
"	ld	a,(#%1)\n"
"	; peephole 0d' loaded a from (#%1) directly instead of using hl.\n"
"} if notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	hl,#%1 + %2\n"
"	ld	a,(hl)\n"
"} by {\n"
"	; peephole 0d'' loaded %2 into a directly instead of using hl.\n"
"	ld	a,(#%1 + %2)\n"
"} if notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	hl,#%1\n"
"	ld	(hl),a\n"
"} by {\n"
"	ld	(#%1),a\n"
"	; peephole 0d''' loaded (#%1) from a directly instead of using hl.\n"
"} if notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	hl,#%1 + %2\n"
"	ld	(hl),a\n"
"} by {\n"
"	ld	(#%1 + %2),a\n"
"	; peephole 0d'''' loaded (#%1) from a directly instead of using hl.\n"
"} if notUsed('hl')\n"
"\n"
"replace restart {\n"
"	srl	%1\n"
"	ld	a,%1\n"
"} by {\n"
"	ld	a,%1\n"
"	; peephole 0e shifted in a instead of %1.\n"
"	srl	a\n"
"} if notVolatile(%1), notUsed(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1,(hl)\n"
"	ld	a,%2 (%3)\n"
"	sub	a,%1\n"
"} by {\n"
"	ld	a,%2 (%3)\n"
"	; peephole 0f used (hl) in sub directly instead of going through %1.\n"
"	sub	a,(hl)\n"
"} if notVolatile(%1), notUsed(%1)\n"
"\n"
"replace restart {\n"
"	inc	bc\n"
"	ld	l,c\n"
"	ld	h,b\n"
"} by {\n"
"	ld	l,c\n"
"	ld	h,b\n"
"	; peephole 0g incremented in hl instead of bc.\n"
"	inc	hl\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	inc	de\n"
"	ld	l,e\n"
"	ld	h,d\n"
"} by {\n"
"	ld	l,e\n"
"	ld	h,d\n"
"	; peephole 0h incremented in hl instead of de.\n"
"	inc	hl\n"
"} if notUsed('de')\n"
"\n"
"replace restart {\n"
"	ld	bc,#%2 + %3\n"
"	ld	a,(bc)\n"
"	ld	c,a\n"
"} by {\n"
"	; peephole 0j used hl for #%2 + %3 instead of bc, not going through a.\n"
"	ld	hl,#%2 + %3\n"
"	ld	c,(hl)\n"
"} if notUsed('a'), notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	c,l\n"
"	ld	b,h\n"
"	ld	a,#%1\n"
"	ld	(bc),a\n"
"} by {\n"
"	ld	c,l\n"
"	ld	b,h\n"
"	ld	(hl),#%1\n"
"	; peephole 0j' loaded #%1 into (hl) instead of (bc).\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	de,#%2 + %3\n"
"	ld	a,(de)\n"
"	ld	e,a\n"
"} by {\n"
"	; peephole 0j'' used hl for #%2 + %3 instead of de, not going through a.\n"
"	ld	hl,#%2 + %3\n"
"	ld	e,(hl)\n"
"} if notUsed('a'), notUsed('hl'), notUsed('d')\n"
"\n"
"replace restart {\n"
"	ex	de, hl\n"
"	push	hl\n"
"} by {\n"
"	; peephole 0k pushed de directly instead of going through hl.\n"
"	push	de\n"
"} if notUsed('de'), notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ex	de, hl\n"
"	push	de\n"
"} by {\n"
"	; peephole 0k' pushed hl directly instead of going through de.\n"
"	push	hl\n"
"} if notUsed('de'), notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	l,%1\n"
"	ld	h,d\n"
"	push	hl\n"
"} by {\n"
"	; peephole 0k'' pushed de instead of hl removing a load.\n"
"	ld	e,%1\n"
"	push	de\n"
"} if notUsed('hl'), notUsed('e')\n"
"\n"
"replace restart {\n"
"	ex	de, hl\n"
"	push	bc\n"
"	push	de\n"
"} by {\n"
"	; peephole 0l pushed hl directly instead of going through de.\n"
"	push	bc\n"
"	push	hl\n"
"} if notUsed('de'), notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	l,c\n"
"	ld	h,b\n"
"	push	hl\n"
"} by {\n"
"	; peephole 0m pushed bc directly instead of going through hl.\n"
"	push	bc\n"
"} if notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	l,%1\n"
"	ld	h,b\n"
"	push	hl\n"
"} by {\n"
"	; peephole 0m' pushed bc instead of hl removing a load.\n"
"	ld	c,%1\n"
"	push	bc\n"
"} if notUsed('hl'), notUsed('c')\n"
"\n"
"replace restart {\n"
"	ld	c,l\n"
"	ld	b,h\n"
"	push	%1\n"
"	push	bc\n"
"} by {\n"
"	; peephole 0m'' pushed hl directly instead of going through bc.\n"
"	push	%1\n"
"	push	hl\n"
"} if notUsed('bc'), notSame(%1 'bc')\n"
"\n"
"replace restart {\n"
"	ld	c,a\n"
"	push	de\n"
"	ld	a,c\n"
"} by {\n"
"	; peephole 0n removed redundant load of a through c.\n"
"	push	de\n"
"} if notUsed('c')\n"
"\n"
"replace restart {\n"
"	ld	c, e\n"
"	ld	b, d\n"
"	ld	a, (bc)\n"
"} by {\n"
"	; peephole 0o used de directly instead of going through bc.\n"
"	ld	a, (de)\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	pop	de\n"
"	ld	l, e\n"
"	ld	h, d\n"
"} by {\n"
"	; peephole 0p popped hl directly instead of going through de.\n"
"	pop	hl\n"
"} if notUsed('de')\n"
"\n"
"replace restart {\n"
"	pop	bc\n"
"	ld	l, c\n"
"	ld	h, b\n"
"} by {\n"
"	; peephole 0p' popped hl directly instead of going through bc.\n"
"	pop	hl\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	ld	%1 (ix), %2\n"
"	ld	%3, %1 (ix)\n"
"} by {\n"
"	; peephole 0r loaded %3 from %2 instead of going through %1 (ix).\n"
"	ld	%1 (ix), %2\n"
"	ld	%3, %2\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1, a\n"
"	ld	%2, %3\n"
"	ld	%4, %1\n"
"} by {\n"
"	; peephole 0t loaded %4 from a instead of going through %1.\n"
"	ld	%1, a\n"
"	ld	%2, %3\n"
"	ld	%4, a\n"
"} if notVolatile(%1), operandsNotRelated(%1 %3), operandsNotRelated(%1 %2), operandsNotRelated(%2 'a')\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	a,%2\n"
"	adc	a,#%3\n"
"	ld	%4,%1\n"
"} by {\n"
"	ld	%1,a\n"
"	; peephole 0t' loaded %4 from a instead of going through %1.\n"
"	ld	%4,a\n"
"	ld	a,%2\n"
"	adc	a,#%3\n"
"} if notVolatile(%1), operandsNotRelated(%1 %2), operandsNotRelated(%4 %2)\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	a,#%2\n"
"	adc	a,#%3\n"
"	ld	%4,%1\n"
"} by {\n"
"	ld	%1,a\n"
"	; peephole 0t'' loaded %4 from a instead of going through %1.\n"
"	ld	%4,a\n"
"	ld	a,#%2\n"
"	adc	a,#%3\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	ld	l,%1 (ix)\n"
"	ld	h,%2 (ix)\n"
"	ld	%3,(hl)\n"
"	srl	%3\n"
"	ld	l,%1 (ix)\n"
"	ld	h,%2 (ix)\n"
"	ld	(hl),%3\n"
"} by {	\n"
"	ld	l,%1 (ix)\n"
"	ld	h,%2 (ix)\n"
"	; peephole 0w shifted (hl) in place.\n"
"	srl	(hl)\n"
"	ld	%3,(hl)\n"
"} if notVolatile(%3)\n"
"\n"
"replace restart {\n"
"	push	af\n"
"	inc	sp\n"
"	ld	a,e\n"
"	push	af\n"
"	inc	sp\n"
"} by {\n"
"	; peephole 0x pushed de instead of pushing a twice.\n"
"	ld	d,a\n"
"	push	de\n"
"} if notUsed('d'), notUsed('a')\n"
"\n"
"replace restart {\n"
"	push	af\n"
"	inc	sp\n"
"	ld	a,#%1\n"
"	push	af\n"
"	inc	sp\n"
"} by {\n"
"	; peephole 0x' pushed de instead of pushing a twice.\n"
"	ld	d,a\n"
"	ld	e,#%1\n"
"	push	de\n"
"} if notUsed('de')\n"
"\n"
"replace restart {\n"
"	push	af\n"
"	inc	sp\n"
"	ld	a,c\n"
"	push	af\n"
"	inc	sp\n"
"} by {\n"
"	; peephole 0y pushed bc instead of pushing a twice.\n"
"	ld	b,a\n"
"	push	bc\n"
"} if notUsed('b'), notUsed('a')\n"
"\n"
"replace restart {\n"
"	push	af\n"
"	inc	sp\n"
"	ld	a,#%1\n"
"	push	af\n"
"	inc	sp\n"
"} by {\n"
"	; peephole 0y' pushed bc instead of pushing a twice.\n"
"	ld	b,a\n"
"	ld	c,#%1\n"
"	push	bc\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	push	bc\n"
"	inc	sp\n"
"	ld	a, c\n"
"	push	af\n"
"	inc	sp\n"
"} by {\n"
"	push	bc\n"
"	ld	a, c\n"
"	; peephole 0y'' simplified pushing bc.\n"
"}\n"
"\n"
"replace restart {\n"
"	push	de\n"
"	inc	sp\n"
"	ld	a, #%1\n"
"	push	af\n"
"	inc	sp\n"
"} by {\n"
"	ld	e, #%1\n"
"	push	de\n"
"	; peephole 0y'' simplified pushing de.\n"
"} if notUsed('e')\n"
"\n"
"replace restart {\n"
"	ld	a,#%1\n"
"	ld	d,a\n"
"} by {\n"
"	; peephole 0z loaded #%1 into d directly instead of going through a.\n"
"	ld	d,#%1\n"
"} if notUsed('a')\n"
"\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	%2,%1\n"
"} by {\n"
"	; peephole 0z'-nerfed loaded %2 from a directly instead of going through %1.\n"
"	ld	%2,a\n"
"} if notUsed(%1)\n"
"\n"
"replace restart {\n"
"	ld	a,%1 (ix)\n"
"	push	af\n"
"	inc	sp\n"
"	ld	a,%2 (ix)\n"
"	push	af\n"
"	inc	sp\n"
"} by {\n"
"	; peephole 0za pushed %1 (ix), %2(ix) through hl instead of af.\n"
"	ld	h,%1 (ix)\n"
"	ld	l,%2 (ix)\n"
"	push	hl\n"
"} if notUsed('a'), notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	c, l\n"
"	ld	b, h\n"
"	push	bc\n"
"} by {\n"
"	; peephole 0zb pushed hl instead of bc.\n"
"	push	hl\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	pop	%1\n"
"	push	%1\n"
"} by {\n"
"	; peephole 0zc eleminated dead pop/push pair.\n"
"} if notUsed(%1)\n"
"\n"
"replace restart {\n"
"	inc	%1\n"
"	dec	%1\n"
"	push	%2\n"
"	ld	%3, %4\n"
"	inc	%1\n"
"} by {\n"
"	; peephole 0zc' eliminated dead inc/dec pair.\n"
"	push	%2\n"
"	ld	%3, %4\n"
"	inc	%1\n"
"} if operandsNotRelated(%2 'af')\n"
"\n"
"replace restart {\n"
"	ld	iy,#%1\n"
"	or	a,%2 (iy)\n"
"} by {\n"
"	; peephole 0zd used hl instead of iy.\n"
"	ld	hl,#%1 + %2\n"
"	or	a,(hl)\n"
"} if notUsed('iy'), notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	iy,#%1\n"
"	ld	%2,%3 (iy)\n"
"} by {\n"
"	; peephole 0ze used hl instead of iy.\n"
"	ld	hl,#%1 + %3\n"
"	ld	%2,(hl)\n"
"} if notUsed('iy'), notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	iy,#%1\n"
"	ld	%2 (iy),%3\n"
"	ld	l,%2 (iy)\n"
"} by {\n"
"	; peephole 0ze' used hl instead of iy.\n"
"	ld	hl,#%1 + %2\n"
"	ld	(hl),%3\n"
"	ld	l,(hl)\n"
"} if notUsed('iy'), notUsed('h')\n"
"\n"
"replace restart {\n"
"	ld	iy,#%1\n"
"	ld	%2 (%3), %4\n"
"} by {\n"
"	; peephole 0zf used hl instead of iy.\n"
"	ld	hl,#%1 + %2\n"
"	ld	(hl), %4\n"
"} if notUsed('iy'), notUsed('hl'), operandsNotRelated(%4 'h'), operandsNotRelated(%4 'l')\n"
"\n"
"replace restart {\n"
"	ld	%1,(hl)\n"
"	or	a,%1\n"
"} by {\n"
"	or	a,(hl)\n"
"	; peephole 0zf' used (hl) directly instead of going through %1.\n"
"} if notUsed(%1), operandsNotRelated(%1 'a')\n"
"\n"
"replace restart {\n"
"	ld	e,l\n"
"	ld	d,h\n"
"	ld	%1,(de)\n"
"} by {\n"
"	; peephole 0zg loaded %1 from (hl) directly instead of going through (de).\n"
"	ld	%1,(hl)\n"
"} if notUsed('de')\n"
"\n"
"replace restart {\n"
"	ld	c,l\n"
"	ld	b,h\n"
"	ld	%1,(bc)\n"
"} by {\n"
"	; peephole 0zh loaded %1 from (hl) directly instead of going through (bc).\n"
"	ld	%1,(hl)\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	ld	c,l\n"
"	ld	b,h\n"
"	inc	bc\n"
"} by {\n"
"	; peephole 0zi incremented in hl instead of bc.\n"
"	inc	hl\n"
"	ld	c,l\n"
"	ld	b,h\n"
"} if notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	a,%1 (%2)\n"
"	bit	%3,a\n"
"} by {\n"
"	; peephole 0zj tested bit of %1 (%2) directly instead of going through a.\n"
"	bit	%3,%1 (%2)\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	ld	a,b\n"
"	bit	%1,a\n"
"} by {\n"
"	; peephole 0zj' tested bit %1 of b directly instead of going through a.\n"
"	bit	%1,b\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	ld	a,d\n"
"	bit	%1,a\n"
"} by {\n"
"	; peephole 0zj'' tested bit %1 of d directly instead of going through a.\n"
"	bit	%1,d\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	ld	a, %1\n"
"	set	%2, a\n"
"	ld	%1, a\n"
"} by {\n"
"	; peephole 0zj''' set bit %1 of (hl) directly instead of going through a.\n"
"	set	%2, %1\n"
"} if notUsed('a'), canAssign('b' %1)\n"
"\n"
"replace restart {\n"
"	ld	bc, #%1 + %2\n"
"	ld	l,c\n"
"	ld	h,b\n"
"} by {\n"
"	; peephole 0zk stored constant #%1 + %2 into hl directly instead of going through bc.\n"
"	ld	hl, #%1 + %2\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	ld	c, %1 (%2)\n"
"	ld	b, %3 (%4)\n"
"	ld	l,c\n"
"	ld	h,b\n"
"} by {\n"
"	; peephole 0zk' stored %1 (%2) %3 (%4) into hl directly instead of going through bc.\n"
"	ld	l, %1 (%2)\n"
"	ld	h, %3 (%4)\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	ld	c, %1\n"
"	ld	b, %2\n"
"	ld	l,c\n"
"	ld	h,b\n"
"} by {\n"
"	; peephole 0zk'' stored %2%1 into hl directly instead of going through bc.\n"
"	ld	l, %1\n"
"	ld	h, %2\n"
"} if notUsed('bc'), operandsNotRelated(%2 'l')\n"
"\n"
"replace restart {\n"
"	jp	NC,%1\n"
"	jp	%2\n"
"%1:\n"
"} by {\n"
"	jp	C,%2\n"
"	; peephole 3 removed jp by using inverse jump logic\n"
"%1:\n"
"} if labelRefCountChange(%1 -1)\n"
"\n"
"replace restart {\n"
"	jp	C,%1\n"
"	jp	%2\n"
"%1:\n"
"} by {\n"
"	jp	NC,%2\n"
"	; peephole 4 removed jp by using inverse jump logic\n"
"%1:\n"
"} if labelRefCountChange(%1 -1)\n"
"\n"
"replace restart {\n"
"	jp	NZ,%1\n"
"	jp	%2\n"
"%1:\n"
"} by {\n"
"	jp	Z,%2\n"
"	; peephole 5 removed jp by using inverse jump logic\n"
"%1:\n"
"} if labelRefCountChange(%1 -1)\n"
"\n"
"replace restart {\n"
"	jp	Z,%1\n"
"	jp	%2\n"
"%1:\n"
"} by {\n"
"	jp	NZ,%2\n"
"	; peephole 6 removed jp by using inverse jump logic\n"
"%1:\n"
"} if labelRefCountChange(%1 -1)\n"
"\n"
"replace restart {\n"
"	ld	%1,#0x00\n"
"	jp	%2\n"
"%3:\n"
"	ld	%1,#0x01\n"
"%2:\n"
"	bit	0,%1\n"
"	jp	Z,%4\n"
"} by {\n"
"	ld	%1,#0x00\n"
"	jp	%4\n"
"	; peephole 6a redirected jump from %2 to %4\n"
"%3:\n"
"	ld	%1,#0x01\n"
"%2:\n"
"	bit	0,%1\n"
"	jp	Z,%4\n"
"} if labelRefCountChange(%2 -1), labelRefCountChange(%4 +1)\n"
"\n"
"\n"
"replace restart {\n"
"	jp	%1\n"
"	ld	%2, #%3\n"
"%1:\n"
"} by {\n"
"	; peephole 6b removed unecessary jump.\n"
"%1:\n"
"} if labelRefCountChange(%1 -1)\n"
"\n"
"replace restart {\n"
"	ld	%1,#0x01\n"
"	xor	a,a\n"
"	or	a,%1\n"
"	jp	Z,%2\n"
"} by {\n"
"	ld	%1,#0x01\n"
"	ld	a,%1\n"
"	; peephole 6b' removed never taken conditional jump.\n"
"} if labelRefCountChange(%2 -1)\n"
"\n"
"replace restart {\n"
"	ld	%1, #0x01\n"
"	bit	0,%1\n"
"	jp	Z,%2\n"
"} by {\n"
"	ld	%1, #0x01\n"
"	; peephole 6c eliminated conditional jump to %2\n"
"} if labelRefCountChange(%2 -1)\n"
"\n"
"replace restart {\n"
"	jp	%5\n"
"} by {\n"
"	jp	%6\n"
"	; peephole 7 jumped to %6 directly instead of via %5.\n"
"} if labelIsUncondJump(), notSame(%5 %6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)\n"
"\n"
"replace restart {\n"
"	jp	%1,%5\n"
"} by {\n"
"	jp	%1,%6\n"
"	; peephole 8 jumped to %6 directly instead of via %5.\n"
"} if labelIsUncondJump(), notSame(%5 %6), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)\n"
"\n"
"replace restart {\n"
"	xor	a,a\n"
"	ld	a,#0x00\n"
"} by {\n"
"	xor	a,a\n"
"	; peephole 10 removed redundant load of 0 into a.\n"
"}\n"
"\n"
"replace {\n"
"	ld	e,#0x%1\n"
"	ld	d,#0x%2\n"
"} by {\n"
"	ld	de,#0x%2%1\n"
"	; peephole 11 combined constant loads into register pair.\n"
"}\n"
"\n"
"replace {\n"
"	ld	l,#0x%1\n"
"	ld	h,#0x%2\n"
"} by {\n"
"	ld	hl,#0x%2%1\n"
"	; peephole 12 combined constant loads into register pair.\n"
"}\n"
"\n"
"replace {\n"
"	ld	c,#0x%1\n"
"	ld	b,#0x%2\n"
"} by {\n"
"	ld	bc,#0x%2%1\n"
"	; peephole 13 combined constant loads into register pair.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	a,%1\n"
"} by {\n"
"	ld	%1,a\n"
"	; peephole 14 removed redundant load from %1 into a.\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	ld	a,%1\n"
"	ld	%1,a\n"
"} by {\n"
"	ld	a,%1\n"
"	; peephole 15 removed redundant load from a into %1.\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	a,%2\n"
"	or	a,%1\n"
"} by {\n"
"	ld	%1,a\n"
"	or	a,%2\n"
"	; peephole 17a removed load by reordering or arguments.\n"
"} if notVolatile(%1), canAssign('b' %2)\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	a,%2 (ix)\n"
"	or	a,%1\n"
"} by {\n"
"	ld	%1,a\n"
"	or	a,%2 (ix)\n"
"	; peephole 17b removed load by reordering or arguments.\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	xor	a,a\n"
"	or	a,%1\n"
"} by {\n"
"	ld	%1,a\n"
"	or	a,a\n"
"	; peephole 18 used value still in a instead of loading it from %1.\n"
"}\n"
"\n"
"replace restart {\n"
"	or	a,%1\n"
"	or	a,a\n"
"} by {\n"
"	or	a,%1\n"
"	; peephole 19 removed redundant or after or.\n"
"}\n"
"\n"
"replace restart {\n"
"	or	a,%1 (%2)\n"
"	or	a,a\n"
"} by {\n"
"	or	a,%1 (%2)\n"
"	; peephole 19a removed redundant or after or.\n"
"}\n"
"\n"
"replace restart {\n"
"	and	a,%1\n"
"	or	a,a\n"
"} by {\n"
"	and	a,%1\n"
"	; peephole 20 removed redundant or after and.\n"
"}\n"
"\n"
"replace restart {\n"
"	and	a,%1 (%2)\n"
"	or	a,a\n"
"} by {\n"
"	and	a,%1 (%2)\n"
"	; peephole 20a removed redundant or after and.\n"
"}\n"
"\n"
"replace restart {\n"
"	xor	a,%1\n"
"	or	a,a\n"
"} by {\n"
"	xor	a,%1\n"
"	; peephole 21 removed redundant or after xor.\n"
"}\n"
"\n"
"replace restart {\n"
"	xor	a,%1 (%2)\n"
"	or	a,a\n"
"} by {\n"
"	xor	a,%1 (%2)\n"
"	; peephole 21a removed redundant or after xor.\n"
"}\n"
"\n"
"replace {\n"
"	ld	%1,%2\n"
"	ld	a,%2\n"
"} by {\n"
"	ld	a,%2\n"
"	ld	%1,a\n"
"	; peephole 23 load value in a first and use it next\n"
"} if notVolatile(%1 %2)\n"
"\n"
"replace restart {\n"
"	ld	%1,%2\n"
"	ld	%3,%4\n"
"	ld	%2,%1\n"
"	ld	%4,%3\n"
"} by {\n"
"	ld	%1,%2\n"
"	ld	%3,%4\n"
"	; peephole 24 removed redundant load from %3%1 into %4%2\n"
"} if notVolatile(%1 %2 %3 %4)\n"
"\n"
"replace restart {\n"
"	ld	a,c\n"
"	push	af\n"
"	inc	sp\n"
"	ld	a,#%2\n"
"	push	af\n"
"	inc	sp\n"
"	call	%3\n"
"} by {\n"
"	ld	b,c\n"
"	ld	c,#%2\n"
"	push	bc\n"
"	; peephole 31 moved and pushed arguments c and #%2 through bc instead of pushing them individually.\n"
"	call	%3\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	a,e\n"
"	push	af\n"
"	inc	sp\n"
"	ld	a,#%2\n"
"	push	af\n"
"	inc	sp\n"
"	call	%3\n"
"} by {\n"
"	ld	d,e\n"
"	ld	e,#%2\n"
"	push	de\n"
"	; peephole 32 moved and pushed arguments e and #%2 through de instead of pushing them individually.\n"
"	call	%3\n"
"}\n"
"\n"
"replace restart {\n"
"	push	de\n"
"	inc	sp\n"
"	ld	a,e\n"
"	push	af\n"
"	inc	sp\n"
"} by {\n"
"	push	de\n"
"	; peephole 32' pushed de\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	ld	iy,%1\n"
"	add	iy,sp\n"
"	ld	sp,iy\n"
"} by {\n"
"	ld	hl,%1\n"
"	add	hl,sp\n"
"	ld	sp,hl\n"
"	; peephole 32'' fixed stack using hl instead of iy.\n"
"} if notUsed('hl'), notUsed('iy')\n"
"\n"
"replace restart {\n"
"	ld	a,%1\n"
"	sub	a,%2\n"
"	jp	%3,%4\n"
"	ld	a,%1\n"
"} by {\n"
"	ld	a,%1\n"
"	cp	a,%2\n"
"	jp	%3,%4\n"
"	; peephole 33 removed load by replacing sub with cp\n"
"	assert	a=%1\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	assert	a=%1\n"
"	sub	a,%2\n"
"	jp	%3,%4\n"
"	ld	a,%1\n"
"} by {\n"
"	cp	a,#%2\n"
"	jp	%3,%4\n"
"	; peephole 34 removed load by replacing sub with cp\n"
"	assert	a=%1\n"
"}\n"
"\n"
"replace restart {\n"
"	assert	a=%1\n"
"} by {\n"
"}\n"
"\n"
"replace restart {\n"
"	sub	a,#0xFF\n"
"	jp	Z,%1\n"
"} by {\n"
"	inc	a\n"
"	; peephole 35 replaced sub a,#0xFF by inc a.\n"
"	jp	Z,%1\n"
"}\n"
"\n"
"replace restart {\n"
"	sub	a,#0xFF\n"
"	jp	NZ,%1\n"
"} by {\n"
"	inc	a\n"
"	; peephole 36 replaced sub a,#0xFF by inc a.\n"
"	jp	NZ,%1\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	bc,#%1 + %2\n"
"	ld	a,c\n"
"	add	a,%3\n"
"	ld	c,a\n"
"	ld	a,b\n"
"	adc	a,%4\n"
"	ld	b,a\n"
"} by {\n"
"	ld	a,#<(%1 + %2)\n"
"	add	a,%3\n"
"	ld	c,a\n"
"	ld	a,#>(%1 + %2)\n"
"	; peephole 37 directly used (%1 + %2) in calculation instead of placing it in bc first.\n"
"	adc	a,%4\n"
"	ld	b,a\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	de,#%1 + %2\n"
"	ld	a,e\n"
"	add	a,%3\n"
"	ld	e,a\n"
"	ld	a,d\n"
"	adc	a,%4\n"
"	ld	d,a\n"
"} by {\n"
"	ld	a,#<(%1 + %2)\n"
"	add	a,%3\n"
"	ld	e,a\n"
"	ld	a,#>(%1 + %2)\n"
"	; peephole 38 directly used (%1 + %2) in calculation instead of placing it in de first.\n"
"	adc	a,%4\n"
"	ld	d,a\n"
"}\n"
"\n"
"replace restart {\n"
"	rlca\n"
"	ld	a,#0x00\n"
"	rla\n"
"} by {\n"
"	rlca\n"
"	and	a,#0x01\n"
"	; peephole 39 replaced zero load, rla by and since rlca writes the same value to carry bit and least significant bit.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1,%2\n"
"	push	%1\n"
"	pop	%4\n"
"	ld	%1,%3\n"
"} by {\n"
"	ld	%4,%2\n"
"	; peephole 40 moved %2 directly into de instead of going through %1.\n"
"	ld	%1,%3\n"
"}\n"
"\n"
"replace restart {\n"
"	add	a,#0x00\n"
"	ld	%2,a\n"
"	ld	a,%3\n"
"	adc	a,%4\n"
"} by {\n"
"	; peephole 41 removed lower part of multibyte addition.\n"
"	ld	%2,a\n"
"	ld	a,%3\n"
"	add	a,%4\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	a, l\n"
"	add	a, #0x%1\n"
"	ld	l, a\n"
"	ld	a, h\n"
"	adc	a, #0x%2\n"
"	ld	h, a\n"
"} by {\n"
"	ld	de, #0x%2%1\n"
"	add	hl, de\n"
"	; peephole 41a used 16-bit addition.\n"
"	ld	a, h\n"
"} if notUsed('de')\n"
"\n"
"replace restart {\n"
"	ld	a, l\n"
"	add	a, #0x%1\n"
"	ld	l, a\n"
"	ld	a, h\n"
"	adc	a, #0x%2\n"
"	ld	h, a\n"
"} by {\n"
"	ld	bc, #0x%2%1\n"
"	add	hl, bc\n"
"	; peephole 41b used 16-bit addition.\n"
"	ld	a, h\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	ld	a, l\n"
"	add	a, #0x%1\n"
"	ld	e, a\n"
"	ld	a, h\n"
"	adc	a, #0x%2\n"
"	ld	d, a\n"
"} by {\n"
"	ld	de, #0x%2%1\n"
"	add	hl, de\n"
"	; peephole 41c used 16-bit addition.\n"
"	ld	e, l\n"
"	ld	d, h\n"
"	ld	a, h\n"
"} if notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	a, l\n"
"	add	a, #0x%1\n"
"	ld	c, a\n"
"	ld	a, h\n"
"	adc	a, #0x%2\n"
"	ld	b, a\n"
"} by {\n"
"	ld	bc, #0x%2%1\n"
"	add	hl,bc\n"
"	; peephole 41d used 16-bit addition.\n"
"	ld	c, l\n"
"	ld	b, h\n"
"	ld	a, h\n"
"} if notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	a,%2\n"
"	add	a,%1\n"
"} by {\n"
"	; peephole 42 removed loads by exploiting commutativity of addition.\n"
"	add	a,%2\n"
"} if notVolatile(%1), notUsed(%1), operandsNotRelated(%2 '(bc)' '(de)'), canAssign('b' %2)\n"
"\n"
"replace restart {\n"
"	ld	%1 (ix),a\n"
"	ld	a,#%2\n"
"	add	a,%1 (ix)\n"
"} by {\n"
"	ld	%1 (ix),a\n"
"	; peephole 42a removed loads by exploiting commutativity of addition.\n"
"	add	a,#%2\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1, a\n"
"	sla	%1\n"
"	ld	a, %2\n"
"	//add	%3, %4\n"
"} by {\n"
"	add	a, a\n"
"	; peephole 42b shifted in accumulator insted of %1\n"
"	ld	%1, a\n"
"	ld	a, %2\n"
"	//add	%3, %4\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1, a\n"
"	sla	%1\n"
"	sla	%1\n"
"	ld	a, %2\n"
"	//add	%3, %4\n"
"} by {\n"
"	add	a, a\n"
"	add	a, a\n"
"	; peephole 42b' shifted in accumulator insted of %1\n"
"	ld	%1, a\n"
"	ld	a, %2\n"
"	//add	%3, %4\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	l,%1 (ix)\n"
"	ld	h,%2 (ix)\n"
"	ld	a,(hl)\n"
"	inc	a\n"
"	ld	l,%1 (ix)\n"
"	ld	h,%2 (ix)\n"
"	ld	(hl),a\n"
"} by {\n"
"	ld	l,%1 (ix)\n"
"	ld	h,%2 (ix)\n"
"	inc	(hl)\n"
"	; peephole 42c incremented in (hl) instead of going through a.\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	ld	l,%1 (ix)\n"
"	ld	h,%2 (ix)\n"
"	ld	a,(hl)\n"
"	dec	a\n"
"	ld	l,%1 (ix)\n"
"	ld	h,%2 (ix)\n"
"	ld	(hl),a\n"
"} by {\n"
"	ld	l,%1 (ix)\n"
"	ld	h,%2 (ix)\n"
"	dec	(hl)\n"
"	; peephole 42d decremented in (hl) instead of going through a.\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	a,%2\n"
"	add	a,%1\n"
"} by {\n"
"	ld	%1, a\n"
"	; peephole 43 removed load by exploiting commutativity of addition.\n"
"	add	a,%2\n"
"} if operandsNotRelated(%2 '(bc)' '(de)'), canAssign('b' %2)\n"
"\n"
"replace restart {\n"
"	ld	c,l\n"
"	ld	b,h\n"
"	ld	hl,#%1\n"
"	add	hl,bc\n"
"} by {\n"
"	; peephole 43a removed loads by exploiting commutativity of addition.\n"
"	ld	bc,#%1\n"
"	add	hl,bc\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	ld	hl,#%1\n"
"	add	hl,%2\n"
"	ld	bc,#%4\n"
"	add	hl,bc\n"
"} by {\n"
"	; peephole 43b removed loads by exploiting commutativity of addition.\n"
"	ld	hl,#%1 + %4\n"
"	add	hl,%2\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	ld	c,e\n"
"	ld	b,d\n"
"	ld	hl,#%1\n"
"	add	hl,bc\n"
"} by {\n"
"	; peephole 43c removed loads by exploiting commutativity of addition.\n"
"	ld	hl,#%1\n"
"	add	hl,de\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	sla	c\n"
"	rl	b\n"
"	add	hl, bc\n"
"} by {\n"
"	add	hl, bc\n"
"	; peephole 43d replaced left shift of bc by addition.\n"
"	add	hl, bc\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	xor	a,a\n"
"	or	a,%3\n"
"} by {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	; peephole 44 removed redundant zeroing of a (which has just been tested to be #0x00).\n"
"	or	a,%3\n"
"}\n"
"\n"
"replace restart {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	ld	%3,#0x00\n"
"} by {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	ld	%3,a\n"
"	; peephole 45 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	and	a,%1\n"
"	jp	NZ,%2\n"
"	ld	%3,#0x00\n"
"} by {\n"
"	and	a,%1\n"
"	jp	NZ,%2\n"
"	ld	%3,a\n"
"	; peephole 46 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	ld	%3,#0x00\n"
"} by {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	ld	%3,a\n"
"	; peephole 47 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	dec	a\n"
"	jp	NZ,%1\n"
"	ld	%2,#0x00\n"
"} by {\n"
"	dec	a\n"
"	jp	NZ,%1\n"
"	ld	%2,a\n"
"	; peephole 48 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	ld	a,%3\n"
"	or	a,a\n"
"} by {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	or	a,%3\n"
"	; peephole 49 shortened or using a (which has just been tested to be #0x00).\n"
"} if operandsNotRelated(%3 '(bc)' '(de)'), canAssign('b' %2)\n"
"\n"
"replace restart {\n"
"	and	a,%1\n"
"	jp	NZ,%2\n"
"	ld	a,%3\n"
"	or	a,a\n"
"} by {\n"
"	and	a,%1\n"
"	jp	NZ,%2\n"
"	or	a,%3\n"
"	; peephole 50 shortened or using a (which has just been tested to be #0x00).\n"
"} if operandsNotRelated(%3 '(bc)' '(de)')\n"
"\n"
"replace restart {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	ld	a,%3\n"
"	or	a,a\n"
"} by {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	or	a,%3\n"
"	; peephole 51 shortened or using a (which has just been tested to be #0x00).\n"
"} if notSame(%3 '(bc)' '(de)'), canAssign('b' %2)\n"
"\n"
"replace restart {\n"
"	dec	a\n"
"	jp	NZ,%1\n"
"	ld	a,%2\n"
"	or	a,a\n"
"} by {\n"
"	dec	a\n"
"	jp	NZ,%1\n"
"	or	a,%2\n"
"	; peephole 52 shortened or using a (which has just been tested to be #0x00).\n"
"}\n"
"if operandsNotRelated(%2 '(bc)' '(de)')\n"
"\n"
"replace restart {\n"
"	dec	%1 (%2)\n"
"	xor	a,a\n"
"	or	a, %1 (%2)\n"
"	jp	NZ,%3\n"
"} by {\n"
"	dec	%1 (%2)\n"
"	; Peephole 52a removed nonzeroness test.\n"
"	jp	NZ,%3\n"
"}if notUsed('a')\n"
"\n"
"replace restart {\n"
"	dec	%1 (%2)\n"
"	xor	a,a\n"
"	or	a, %1 (%2)\n"
"	jp	Z,%3\n"
"} by {\n"
"	dec	%1 (%2)\n"
"	; Peephole 52a' removed zeroness test.\n"
"	jp	Z,%3\n"
"}if notUsed('a')\n"
"\n"
"replace restart {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	push	%3\n"
"	ld	%4,#0x00\n"
"} by {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	push	%3\n"
"	ld	%4,a\n"
"	; peephole 53 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	and	a,%1\n"
"	jp	NZ,%2\n"
"	push	%3\n"
"	ld	%4,#0x00\n"
"} by {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	push	%3\n"
"	ld	%4,a\n"
"	; peephole 54 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	push	%3\n"
"	ld	%4,#0x00\n"
"} by {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	push	%3\n"
"	ld	%4,a\n"
"	; peephole 55 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	dec	a\n"
"	jp	NZ,%1\n"
"	push	%2\n"
"	ld	%3,#0x00\n"
"} by {\n"
"	dec	a\n"
"	jp	NZ,%1\n"
"	push	%2\n"
"	ld	%3,a\n"
"	; peephole 56 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	de,#%1 + %2\n"
"	inc	de\n"
"} by {\n"
"	ld	de,#%1 + %2+1\n"
"	; peephole 59 moved increment of de to constant.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	bc,#%1 + %2\n"
"	inc	bc\n"
"} by {\n"
"	ld	bc,#%1 + %2+1\n"
"	; peephole 60 moved increment of bc to constant.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	hl,#%1\n"
"	add	hl,%2\n"
"	inc	hl\n"
"} by {\n"
"	ld	hl,#%1+1\n"
"	add	hl,%2\n"
"	; peephole 62 moved increment of hl to constant.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1,#%2\n"
"	add	hl,%1\n"
"	inc	hl\n"
"} by {\n"
"	ld	%1,#%2+1\n"
"	add	hl,%1\n"
"	; peephole 62a moved increment of hl to constant.\n"
"} if notUsed(%1)\n"
"\n"
"replace restart {\n"
"	ld	bc,#%1\n"
"	ld	a,c\n"
"	add	a,#0x%2\n"
"	ld	c,a\n"
"	ld	a,b\n"
"	adc	a,#0x%3\n"
"	ld	b,a\n"
"} by {\n"
"	ld	bc,#%1 + 0x%3%2\n"
"	; peephole 63 moved addition of constant 0x%3%2 to bc to constant.\n"
"}\n"
"\n"
"replace restart {\n"
"	pop	af\n"
"	ld	sp,%1\n"
"} by {\n"
"	; peephole 64 removed redundant pop af.\n"
"	ld	sp,%1\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	inc	sp\n"
"	ld	sp,%1\n"
"} by {\n"
"	; peephole 64a removed redundant inc sp.\n"
"	ld	sp,%1\n"
"} if notUsed('a')\n"
"\n"
"\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	%2,%1\n"
"	ld	%3,%1\n"
"} by {\n"
"	; peephole 67 loaded %2, %3 from a instead of %1.\n"
"	ld	%1,a\n"
"	ld	%2,a\n"
"	ld	%3,a\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	%2,a\n"
"	ld	%3,%1\n"
"} by {\n"
"	ld	%1,a\n"
"	ld	%2,a\n"
"	; peephole 68 loaded %3 from a instead of %1.\n"
"	ld	%3,a\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1,l\n"
"	xor	a,a\n"
"	or	a,%1\n"
"} by {	\n"
"	ld	%1,l\n"
"	xor	a,a\n"
"	; peephole 69 used l in or instead of %1.\n"
"	or	a,l\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1,#%2\n"
"	ld	%3,%4\n"
"	ld	%1,#%2\n"
"} by {\n"
"	ld	%1,#%2\n"
"	ld	%3,%4\n"
"	; peephole 70 removed load of #%2 into %1 since it's still there.\n"
"} if notVolatile(%1), operandsNotRelated(%3 %1)\n"
"\n"
"replace restart {\n"
"	ld	hl,#%1\n"
"	ld	de,#%1\n"
"} by {\n"
"	; peephole 70a used #%1 from hl for load into de.\n"
"	ld	hl,#%1\n"
"	ld	e,l\n"
"	ld	d,h\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	hl,#%1\n"
"	push	hl\n"
"	ld	l,e\n"
"	ld	h,d\n"
"	jp	(hl)\n"
"%1:\n"
"} by {\n"
"	; peephole 71 used ex to get de into hl.\n"
"	ex	de,hl\n"
"	ld	de,#%1\n"
"	push	de\n"
"	jp	(hl)\n"
"%1:\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1 (ix),l\n"
"	ld	%2 (ix),h\n"
"	ld	%3,%1 (ix)\n"
"	ld	%4,%2 (ix)\n"
"} by {	\n"
"	ld	%1 (ix),l\n"
"	ld	%2 (ix),h\n"
"	; peephole 72 used hl instead of %2 (ix), %1 (ix) to load %4%3.\n"
"	ld	%3,l\n"
"	ld	%4,h\n"
"} if operandsNotRelated('h' %3)\n"
"\n"
"replace restart {\n"
"	ld	%1, a\n"
"	ld	a, %2 (%3)\n"
"	adc	a, #%4\n"
"	ld	%6, %1\n"
"} by {\n"
"	ld	%6, a\n"
"	ld	a, %2 (%3)\n"
"	adc	a, #%4\n"
"	; peephole 76 loaded %6 from a directly instead of going through %1.\n"
"} if notUsed(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1, a\n"
"	ld	a, %2 (%3)\n"
"	adc	a, #%4\n"
"	ld	%5, a\n"
"	ld	%6, %1\n"
"} by {\n"
"	ld	%6, a\n"
"	ld	a, %2 (%3)\n"
"	adc	a, #%4\n"
"	ld	%5, a\n"
"	; peephole 76' loaded %6 from a directly instead of going through %1.\n"
"} if notUsed(%1), notSame(%5 %1), notSame(%5 '(hl)' '(de)' '(bc)'), notSame(%5 %6), notSame(%6 '(hl)' '(de)' '(bc)'), notSame(%5 'a')\n"
"\n"
"replace restart {\n"
"	ld	%1, a\n"
"	ld	a, #%2\n"
"	adc	a, #%3\n"
"	ld	%6, %1\n"
"} by {\n"
"	ld	%6, a\n"
"	ld	a, #%2\n"
"	adc	a, #%3\n"
"	; peephole 77 loaded %6 from a directly instead of going through %1.\n"
"} if notUsed(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1, a\n"
"	ld	a, #%2\n"
"	adc	a, #%3\n"
"	ld	%5, a\n"
"	ld	%6, %1\n"
"} by {\n"
"	ld	%6, a\n"
"	ld	a, #%2\n"
"	adc	a, #%3\n"
"	ld	%5, a\n"
"	; peephole 77' loaded %6 from a directly instead of going through %1.\n"
"} if notUsed(%1), notSame(%5 %1), notSame(%5 %6 '(hl)' '(de)' '(bc)'), notSame(%6 'a')\n"
"\n"
"replace restart {\n"
"	ld	hl, #%1\n"
"	add	hl, %2\n"
"	ex	de, hl\n"
"	ld	hl, #%3\n"
"	add	hl, de\n"
"} by {\n"
"	ld	hl, #%1+%3\n"
"	add	hl, %2\n"
"	; peephole 78 removed addition and loads exploiting commutativity of addition.\n"
"} if notUsed('de')\n"
"\n"
"replace restart {\n"
"	ex	de, hl\n"
"	ld	hl, #%1\n"
"	add	hl, de\n"
"} by {\n"
"	; peephole 78a removed ex exploiting commutativity of addition.\n"
"	ld	de, #%1\n"
"	add	hl, de\n"
"} if notUsed('de')\n"
"\n"
"replace restart {\n"
"	ex	de, hl\n"
"	push	bc\n"
"	ex	de, hl\n"
"} by {\n"
"	push	bc\n"
"	; peephole 78b canceled subsequent ex de, hl.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	hl, #%1\n"
"	add	hl, %2\n"
"	ex	de, hl\n"
"	inc	de\n"
"} by {\n"
"	ld	hl, #%1+1\n"
"	; peephole 79 moved increment to constant.\n"
"	add	hl, %2\n"
"	ex	de, hl\n"
"} if notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	%1,#0x00\n"
"	jp	%3\n"
"%2:\n"
"	ld	%1,#0x01\n"
"%3:\n"
"	xor	a,a\n"
"	cp	a,%1\n"
"	rla\n"
"} by {\n"
"	ld	%1,#0x00\n"
"	jp	%3\n"
"%2:\n"
"	ld	%1,#0x01\n"
"%3:\n"
"	ld	a,%1\n"
"	; peephole 83 replaced cast from bool to bool by assignment.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	a,#0x01\n"
"	jp	%1\n"
"%2:\n"
"	xor	a,a\n"
"%1:\n"
"	sub	a,#0x01\n"
"	ld	a,#0x00\n"
"	rla\n"
"} by {\n"
"	xor	a,a\n"
"	jp	%1\n"
"%2:\n"
"	ld	a,#0x01\n"
"%1:\n"
"	; peephole 84 removed negation.\n"
"} if labelRefCount(%1 1)\n"
"\n"
"replace restart {\n"
"	and	a,#0x01\n"
"	sub	a,#0x01\n"
"	ld	a,#0x00\n"
"	rla\n"
"} by {\n"
"	and	a,#0x01\n"
"	xor	a,#0x01\n"
"	; peephole 84a used xor for negation.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	xor	a,a\n"
"	sbc	a,%1\n"
"} by {\n"
"	ld	%1,a\n"
"	neg\n"
"	; peephole 84b used neg for negation.\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	and	a,#0x01\n"
"	xor	a,#0x01\n"
"	jp	NZ,%1\n"
"} by {\n"
"	and	a,#0x01\n"
"	; peephole 85a removed xor by inverting jump condition.\n"
"	jp	Z,%1\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	and	a,#0x01\n"
"	xor	a,#0x01\n"
"	jp	Z,%1\n"
"} by {\n"
"	and	a,#0x01\n"
"	; peephole 85b removed xor by inverting jump condition.\n"
"	jp	NZ,%1\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	rlca\n"
"	and	a,#0x01\n"
"	jp	NZ,%1\n"
"} by {\n"
"	rlca\n"
"	; peephole 86a jumped by carry instead of bit 0.\n"
"	jp	C,%1\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	rlca\n"
"	and	a,#0x01\n"
"	jp	Z,%1\n"
"} by {\n"
"	rlca\n"
"	; peephole 86b jumped by carry instead of bit 0.\n"
"	jp	NC,%1\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	or	a,a\n"
"	sub	a,#%1\n"
"} by {\n"
"	; peephole 87 removed redundant or.\n"
"	sub	a,#%1\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	a,#0x00\n"
"	rla\n"
"	sub	a,#0x01\n"
"	ld	a,#0x00\n"
"	rla\n"
"} by {\n"
"	ld	a,#0x00\n"
"	ccf\n"
"	; peephole 88 moved negation from bit 0 to carry flag.\n"
"	rla\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	a,#0x00\n"
"	ccf\n"
"	rla\n"
"	or	a,a\n"
"	jp	NZ,%1\n"
"} by {\n"
"	; peephole 89a jumped by carry instead of going through bit 0 of a.\n"
"	jp	NC,%1\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	ld	a,#0x00\n"
"	ccf\n"
"	rla\n"
"	or	a,a\n"
"	jp	Z,%1\n"
"} by {\n"
"	; peephole 89b jumped by carry instead of going through bit 0 of a.\n"
"	jp	C,%1\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	sbc	a,%1\n"
"	rlca\n"
"	jp	C,%2\n"
"} by {\n"
"	sbc	a,%1\n"
"	; peephole 90a jumped by sign instead of going through carry.\n"
"	jp	M,%2\n"
"}\n"
"\n"
"replace restart {\n"
"	sbc	a,%1\n"
"	rlca\n"
"	jp	NC,%2\n"
"} by {\n"
"	sbc	a,%1\n"
"	; peephole 90b jumped by sign instead of going through carry.\n"
"	jp	P,%2\n"
"}\n"
"\n"
"replace restart {\n"
"	jp	NZ,%2\n"
"%1:\n"
"	ld	b,#0x00\n"
"	jp	%3\n"
"%2:\n"
"	ld	b,#0x01\n"
"%3:\n"
"	xor	a,a\n"
"	or	a,b\n"
"	jp	Z,%4\n"
"} by {\n"
"	jp	NZ,%2\n"
"%1:\n"
"	ld	b,#0x00\n"
"	ld	a,b\n"
"	jp	%4\n"
"	; peephole 91 redirected jump from %3 to %4.\n"
"%2:\n"
"	ld	b,#0x01\n"
"%3:\n"
"	xor	a,a\n"
"	or	a,b\n"
"	jp	Z,%4\n"
"} if labelRefCountChange(%3 -1), labelRefCountChange(%4 +1)\n"
"\n"
"replace restart {\n"
"	pop	af\n"
"	push	hl\n"
"} by {\n"
"	; peephole 92 used ex to move hl onto the stack.\n"
"	ex	(sp),hl\n"
"} if notUsed('a'), notUsed('hl')\n"
"\n"
"replace restart {\n"
"	pop	af\n"
"	ld	hl,#%1\n"
"	push	hl\n"
"} by {\n"
"	ld	hl,#%1\n"
"	; peephole 92a used ex to move #%1 onto the stack.\n"
"	ex	(sp),hl\n"
"} if notUsed('a'), notUsed('hl')\n"
"\n"
"replace restart {\n"
"	pop	af\n"
"	inc	sp\n"
"	ld	hl,#%1\n"
"	push	hl\n"
"} by {\n"
"	inc	sp\n"
"	ld	hl,#%1\n"
"	; peephole 93 used ex to move #%1 onto the stack.\n"
"	ex	(sp),hl\n"
"} if notUsed('a'), notUsed('hl')\n"
"\n"
"replace restart {\n"
"	pop	af\n"
"	ld	a,#%1\n"
"	push	af\n"
"	inc	sp\n"
"} by {\n"
"	ld	h,#%1\n"
"	ex	(sp),hl\n"
"	; peephole 94 used ex to move #%1 onto the stack.\n"
"	inc	sp\n"
"} if notUsed('a'), notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	a,%1 (%2)\n"
"	or	a,#0x01\n"
"	ld	%1 (%2),a\n"
"} by {\n"
"	set	0,%1 (%2)\n"
"	; peephole z0 used set instead of or.\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	ld	%1,#%2\n"
"	ld	a,%3 (%1)\n"
"	ld	%4,a\n"
"	ld	%1,#%5\n"
"} by {\n"
"	ld	a,(#%2 + %3)\n"
"	; peephole z1 used #%2 directly instead of going through %1 using indirect addressing.\n"
"	ld	%4,a\n"
"	ld	%1,#%5\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1,#%2\n"
"	ld	%3 (%1),a\n"
"%4:\n"
"	ld	%1,%5\n"
"} by {\n"
"	ld	(#%2 + %3),a\n"
"	; peephole z2 directly used #%2 instead of going through %1 using indirect addressing.\n"
"%4:\n"
"	ld	%1,%5\n"
"}\n"
"\n"
"replace restart {\n"
"	pop	af\n"
"	ld	%1,#%2\n"
"	ld	%3 (%1),%4\n"
"	ld	%1,#%5\n"
"} by {\n"
"	ld	a,%4\n"
"	ld	(#%2 + %3),a\n"
"	; peephole z3 used #%2 directly instead of going through %1 using indirect addressing.\n"
"	pop	af\n"
"	ld	%1,#%5\n"
"} if operandsNotRelated(%3 'a')\n"
"\n"
"replace restart {\n"
"	ld	bc,#%1 + %2\n"
"	ld	a,%3\n"
"	ld	(bc),a\n"
"} by {\n"
"	ld	a,%3\n"
"	ld	(#%1 + %2),a\n"
"	; peephole z4 directly used address #%1 + %2 instead of placing it in bc first.\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	ld	bc,#%1 + %2 + %6\n"
"	ld	a,%3\n"
"	ld	(bc),a\n"
"} by {\n"
"	ld	a,%3\n"
"	ld	(#%1 + %2 + %6),a\n"
"	; peephole z5 directly used address #%1 + %2 + %6 instead of placing it in bc first.\n"
"} if notUsed('bc')\n"
"\n"
"replace restart {\n"
"	ld	c,%1\n"
"	ld	l,c\n"
"	ret\n"
"} by {\n"
"	ld	l,%1\n"
"	; peephole z8 moved %1 directly into l instead of going through c.\n"
"	ret\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	b,h\n"
"	ld	c,l\n"
"	pop	af\n"
"	push	bc\n"
"	call	%1\n"
"} by {\n"
"	ex	(sp),hl\n"
"	; peephole z9 moved hl directly to the stack instead of going through bc.\n"
"	call	%1\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	d,h\n"
"	ld	e,l\n"
"	pop	af\n"
"	push	de\n"
"	call	%1\n"
"} by {\n"
"	ex	(sp),hl\n"
"	; peephole z10 moved hl directly to the stack instead of going through de.\n"
"	call	%1\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	bit	%2,%1\n"
"} by {\n"
"	bit	%2,a\n"
"	; peephole z10a tested bit %2 of a directly instead of going through %1.\n"
"} if notUsed(%1)\n"
"\n"
"replace restart {\n"
"	rla\n"
"	bit	0,a\n"
"	jp	Z,%1\n"
"} by {\n"
"	jp	NC,%1\n"
"	; peephole z10b jumped by carry.\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	rla\n"
"	bit	0,a\n"
"	jp	NZ,%1\n"
"} by {\n"
"	jp	C,%1\n"
"	; peephole z10b' jumped by carry.\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	and	a,#0x01\n"
"	sub	a,#0x01\n"
"	jp	NC,%1\n"
"} by {\n"
"	bit	0,a\n"
"	jp	NZ,%1\n"
"	; peephole z10c jumped by bit test.\n"
"}\n"
"\n"
"replace restart {\n"
"	and	a,#0x01\n"
"	sub	a,#0x01\n"
"	jp	C,%1\n"
"} by {\n"
"	bit	0,a\n"
"	jp	Z,%1\n"
"	; peephole z10c' jumped by bit test.\n"
"}\n"
"\n"
"replace restart {\n"
"	rlca\n"
"	bit	0,a\n"
"} by {\n"
"	bit	7,a\n"
"	; peephole z10d tested bit 7 intead of rotating and testing 0.\n"
"} if notUsed('a')\n"
"\n"
"replace restart {\n"
"	sbc	a,%1\n"
"	bit	7,a\n"
"	jp	Z,%2\n"
"} by {\n"
"	sbc	a,%1\n"
"	jp	P,%2\n"
"	; peephole z10e used sign flag instead of testing bit 7.\n"
"}\n"
"\n"
"replace restart {\n"
"	sbc	a,%1\n"
"	bit	7,a\n"
"	jp	NZ,%2\n"
"} by {\n"
"	sbc	a,%1\n"
"	jp	M,%2\n"
"	; peephole z10e' used sign flag instead of testing bit 7.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	or	a,a\n"
"	jp	%3,%4\n"
"	ld	a,%1\n"
"} by {\n"
"	ld	%1,a\n"
"	or	a,a\n"
"	jp	%3,%4\n"
"	; peephole z10f used value still in a instead of reloading from %1.\n"
"}\n"
"\n"
"replace {\n"
"	jp	%5\n"
"	ret\n"
"} by {\n"
"	jp	%5\n"
"	; peephole z13 removed unused ret.\n"
"}\n"
"\n"
"replace {\n"
"	jp	%5\n"
"	ld	sp,ix\n"
"	pop	ix\n"
"	ret\n"
"} by {\n"
"	jp	%5\n"
"	; peephole z13a removed unused ret.\n"
"}\n"
"\n"
"replace restart {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	xor	a,a\n"
"	jp	%3\n"
"} by {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	; peephole 84' removed redundant zeroing of a (which has just been tested to be #0x00).\n"
"	jp	%3\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	l, e\n"
"	ld	h, d\n"
"	ld	a, (hl)\n"
"} by {\n"
"	; peephole 85 used de directly instead of going through hl.\n"
"	ld	a, (de)\n"
"} if notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	l, c\n"
"	ld	h, b\n"
"	ld	a, (hl)\n"
"} by {\n"
"	; peephole 85a used bc directly instead of going through hl.\n"
"	ld	a, (bc)\n"
"} if notUsed('hl')\n"
"\n"
"barrier\n"
"\n"
"replace restart {\n"
"	ld	d,h\n"
"	ld	e,l\n"
"} by {\n"
"	; peephole 90 used ex to load hl into de.\n"
"	ex	de,hl\n"
"} if notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	e,l\n"
"	ld	d,h\n"
"} by {\n"
"	; peephole 91 used ex to load hl into de.\n"
"	ex	de,hl\n"
"} if notUsed('hl')\n"
"\n"
"replace restart {\n"
"	ld	l,e\n"
"	ld	h,d\n"
"} by {\n"
"	; peephole 92 used ex to load de into hl.\n"
"	ex	de,hl\n"
"} if notUsed('de')\n"
"\n"
"\n"
"replace restart {\n"
"	jp	%5\n"
"} by {\n"
"	ret\n"
"	; peephole z11 replaced jump by return.\n"
"} if labelIsReturnOnly(), labelRefCountChange(%5 -1)\n"
"\n"
"replace restart {\n"
"	jp	%1,%5\n"
"} by {\n"
"	ret	%1\n"
"	; peephole z11a replaced jump by return.\n"
"} if labelIsReturnOnly(), labelRefCountChange(%5 -1)\n"
"\n"
"barrier\n"
"\n"
"replace {\n"
"	add	hl,de\n"
"	pop	de\n"
"	jp	(hl)\n"
"%1:\n"
"	jp	%5\n"
"	jp	%6\n"
"	jp	%7\n"
"%2:\n"
"} by {\n"
"	; peephole z12-3 removed addition using short jumps in jump-table.\n"
"	pop	de\n"
"	jp	(hl)\n"
"%1:\n"
"	jr	%5\n"
"	jr	%6\n"
"	jr	%7\n"
"%2:\n"
"} if labelJTInRange\n"
"\n"
"replace {\n"
"	add	hl,de\n"
"	pop	de\n"
"	jp	(hl)\n"
"%1:\n"
"	jp	%5\n"
"	jp	%6\n"
"	jp	%7\n"
"	jp	%8\n"
"%2:\n"
"} by {\n"
"	; peephole z12-4 removed addition using short jumps in jump-table.\n"
"	pop	de\n"
"	jp	(hl)\n"
"%1:\n"
"	jr	%5\n"
"	jr	%6\n"
"	jr	%7\n"
"	jr	%8\n"
"%2:\n"
"} if labelJTInRange\n"
"\n"
"replace {\n"
"	add	hl,de\n"
"	pop	de\n"
"	jp	(hl)\n"
"%1:\n"
"	jp	%5\n"
"	jp	%6\n"
"	jp	%7\n"
"	jp	%8\n"
"	jp	%9\n"
"%2:\n"
"} by {\n"
"	; peephole z12-5 removed addition using short jumps in jump-table.\n"
"	pop	de\n"
"	jp	(hl)\n"
"%1:\n"
"	jr	%5\n"
"	jr	%6\n"
"	jr	%7\n"
"	jr	%8\n"
"	jr	%9\n"
"%2:\n"
"} if labelJTInRange\n"
"\n"
"replace {\n"
"	add	hl,de\n"
"	pop	de\n"
"	jp	(hl)\n"
"%1:\n"
"	jp	%5\n"
"	jp	%6\n"
"	jp	%7\n"
"	jp	%8\n"
"	jp	%9\n"
"	jp	%10\n"
"%2:\n"
"} by {\n"
"	; peephole z12-6 removed addition using short jumps in jump-table.\n"
"	pop	de\n"
"	jp	(hl)\n"
"%1:\n"
"	jr	%5\n"
"	jr	%6\n"
"	jr	%7\n"
"	jr	%8\n"
"	jr	%9\n"
"	jr	%10\n"
"%2:\n"
"} if labelJTInRange\n"
"\n"
"replace {\n"
"	add	hl,de\n"
"	pop	de\n"
"	jp	(hl)\n"
"%1:\n"
"	jp	%5\n"
"	jp	%6\n"
"	jp	%7\n"
"	jp	%8\n"
"	jp	%9\n"
"	jp	%10\n"
"	jp	%11\n"
"%2:\n"
"} by {\n"
"	; peephole z12-6 removed addition using short jumps in jump-table.\n"
"	pop	de\n"
"	jp	(hl)\n"
"%1:\n"
"	jr	%5\n"
"	jr	%6\n"
"	jr	%7\n"
"	jr	%8\n"
"	jr	%9\n"
"	jr	%10\n"
"	jr	%11\n"
"%2:\n"
"} if labelJTInRange\n"
"\n"
"barrier\n"
"\n"
"replace restart {\n"
"%1:\n"
"} by {\n"
"	; peephole z12 removed unused label %1.\n"
"} if labelRefCount(%1 0)\n"
"\n"
"barrier\n"
"\n"
"replace {\n"
"	jp	%5\n"
"} by {\n"
"	jr	%5\n"
"	; peephole z14 changed absolute to relative unconditional jump.\n"
"} if labelInRange()\n"
"\n"
"replace {\n"
"	jp	Z,%5\n"
"} by {\n"
"	jr	Z,%5\n"
"	; peephole z15 changed absolute to relative conditional jump.\n"
"} if labelInRange()\n"
"\n"
"replace {\n"
"	jp	NZ,%5\n"
"} by {\n"
"	jr	NZ,%5\n"
"	; peephole z16 changed absolute to relative conditional jump.\n"
"} if labelInRange()\n"
"\n"
"replace {\n"
"	jp	C,%5\n"
"} by {\n"
"	jr	C,%5\n"
"	; peephole z17 changed absolute to relative conditional jump.\n"
"} if labelInRange()\n"
"\n"
"replace {\n"
"	jp	NC,%5\n"
"} by {\n"
"	jr	NC,%5\n"
"	; peephole z18 changed absolute to relative conditional jump.\n"
"} if labelInRange()\n"
"\n"
