                              1 ;--------------------------------------------------------------------------
                              2 ;  divunsigned.s
                              3 ;
                              4 ;  Copyright (C) 2000-2010, Michael Hope, Philipp Klaus Krause, Marco Bodrato
                              5 ;
                              6 ;  This library is free software; you can redistribute it and/or modify it
                              7 ;  under the terms of the GNU General Public License as published by the
                              8 ;  Free Software Foundation; either version 2.1, or (at your option) any
                              9 ;  later version.
                             10 ;
                             11 ;  This library is distributed in the hope that it will be useful,
                             12 ;  but WITHOUT ANY WARRANTY; without even the implied warranty of
                             13 ;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
                             14 ;  GNU General Public License for more details.
                             15 ;
                             16 ;  You should have received a copy of the GNU General Public License 
                             17 ;  along with this library; see the file COPYING. If not, write to the
                             18 ;  Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
                             19 ;   MA 02110-1301, USA.
                             20 ;
                             21 ;  As a special exception, if you link this library with other files,
                             22 ;  some of which are compiled with SDCC, to produce an executable,
                             23 ;  this library does not by itself cause the resulting executable to
                             24 ;  be covered by the GNU General Public License. This exception does
                             25 ;  not however invalidate any other reasons why the executable file
                             26 ;   might be covered by the GNU General Public License.
                             27 ;--------------------------------------------------------------------------
                             28 
                             29         ;; Originally from GBDK by Pascal Felber.
                             30 
                             31         .area   _CODE
                             32 
   0000                      33 __divuint_rrx_s::
   0000 F1                   34         pop     af
   0001 E1                   35         pop     hl
   0002 D1                   36         pop     de
   0003 D5                   37         push    de
   0004 E5                   38         push    hl
   0005 F5                   39         push    af
                             40 
   0006 18 0A                41         jr      __divu16
                             42 
   0008                      43 __divuchar_rrx_s::
   0008 21 03 00             44         ld      hl,#2+1
   000B 39                   45         add     hl,sp
                             46 
   000C 5E                   47         ld      e,(hl)
   000D 2B                   48         dec     hl
   000E 6E                   49         ld      l,(hl)
                             50 
                             51         ;; Fall through
   000F                      52 __divuchar_rrx_hds::
   000F                      53 __divu8::
   000F 26 00                54         ld      h,#0x00
   0011 54                   55         ld      d,h
                             56         ; Fall through to __divu16
                             57 
                             58         ;; unsigned 16-bit division
                             59         ;;
                             60         ;; Entry conditions
                             61         ;;   HL = dividend
                             62         ;;   DE = divisor
                             63         ;;
                             64         ;; Exit conditions
                             65         ;;   HL = quotient
                             66         ;;   DE = remainder
                             67         ;;   If divisor is non-zero, carry=0
                             68         ;;   If divisor is 0, carry=1 and both quotient and remainder are 0
                             69         ;;
                             70         ;; Register used: AF,B,DE,HL
   0012                      71 __divuint_rrx_hds::
   0012                      72 __divu16::
                             73         ;; Check for division by zero
   0012 7B                   74         ld      a,e
   0013 B2                   75         or      d
                             76         ;; Two algorithms: one assumes divisor <2^7, the second
                             77         ;; assumes divisor >=2^7; choose the applicable one.
   0014 E6 80                78         and     #0x80
   0016 20 13                79         jr      NZ,.morethan7bits
   0018 B2                   80         or      d
   0019 20 10                81         jr      NZ,.morethan7bits
                             82         ;; Both algorithms "rotate" 24 bits (H,L,A) but roles change.
                             83 
                             84         ;; unsigned 16/7-bit division
   001B                      85 .atmost7bits:
   001B 06 10                86         ld      b,#16           ; bits in dividend and possible quotient
                             87         ;; Carry cleared by AND/OR, this "0" bit will pass trough HL.[*]
   001D ED 6A                88         adc     hl,hl
   001F                      89 .dvloop7:
                             90         ;; HL holds both dividend and quotient. While we shift a bit from
                             91         ;;  MSB of dividend, we shift next bit of quotient in from carry.
                             92         ;; A holds remainder.
   001F 17                   93         rla
                             94 
                             95         ;; If remainder is >= divisor, next bit of quotient is 1.  We try
                             96         ;;  to compute the difference.
   0020 93                   97         sub     a,e
   0021 30 01                98         jr      NC,.nodrop7     ; Jump if remainder is >= dividend
   0023 83                   99         add     a,e             ; Otherwise, restore remainder
                            100         ;; The add above sets the carry, because sbc a,e did set it.
   0024                     101 .nodrop7:
   0024 3F                  102         ccf                     ; Complement borrow so 1 indicates a
                            103                                 ;  successful substraction (this is the
                            104                                 ;  next bit of quotient)
   0025 ED 6A               105         adc     hl,hl
   0027 10 F6               106         djnz    .dvloop7
                            107         ;; Carry now contains the same value it contained before
                            108         ;; entering .dvloop7[*]: "0" = valid result.
   0029 5F                  109         ld      e,a             ; DE = remainder, HL = quotient
   002A C9                  110         ret
                            111 
   002B                     112 .morethan7bits:
   002B 06 09               113         ld      b,#9            ; at most 9 bits in quotient.
   002D 7D                  114         ld      a,l             ; precompute the first 7 shifts, by
   002E 6C                  115         ld      l,h             ;  doing 8
   002F 26 00               116         ld      h,#0
   0031 CB 1D               117         rr      l               ;  undoing 1
   0033                     118 .dvloop:
                            119         ;; Shift next bit of quotient into bit 0 of dividend
                            120         ;; Shift next MSB of dividend into LSB of remainder
                            121         ;; A holds both dividend and quotient. While we shift a bit from
                            122         ;;  MSB of dividend, we shift next bit of quotient in from carry
                            123         ;; HL holds remainder
   0033 ED 6A               124         adc     hl,hl           ; HL < 2^(7+9), no carry, ever.
                            125 
                            126         ;; If remainder is >= divisor, next bit of quotient is 1. We try
                            127         ;;  to compute the difference.
   0035 ED 52               128         sbc     hl,de
   0037 30 01               129         jr      NC,.nodrop      ; Jump if remainder is >= dividend
   0039 19                  130         add     hl,de           ; Otherwise, restore remainder
                            131 	;; The add above sets the carry, because sbc hl,de did set it.
   003A                     132 .nodrop:
   003A 3F                  133         ccf                     ; Complement borrow so 1 indicates a
                            134                                 ;  successful substraction (this is the
                            135                                 ;  next bit of quotient)
   003B 17                  136         rla
   003C 10 F5               137         djnz    .dvloop
                            138         ;; Take care of the ninth quotient bit! after the loop B=0.
   003E CB 10               139         rl      b               ; BA = quotient
                            140         ;; Carry now contains "0" = valid result.
   0040 50                  141         ld      d,b
   0041 5F                  142         ld      e,a             ; DE = quotient, HL = remainder
   0042 EB                  143         ex      de,hl           ; HL = quotient, DE = remainder
   0043 C9                  144         ret
                            145 
